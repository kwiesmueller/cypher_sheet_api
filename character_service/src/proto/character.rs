// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `character.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct CharacterMetadata {
    // message fields
    pub uuid: ::std::string::String,
    pub name: ::std::string::String,
    pub lastUpdated: i64,
    pub revisions: ::std::vec::Vec<i32>,
    pub storage_size: i32,
    pub latest_revision: u64,
    pub storage_uuid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CharacterMetadata {
    fn default() -> &'a CharacterMetadata {
        <CharacterMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CharacterMetadata {
    pub fn new() -> CharacterMetadata {
        ::std::default::Default::default()
    }

    // string uuid = 1;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 lastUpdated = 5;


    pub fn get_lastUpdated(&self) -> i64 {
        self.lastUpdated
    }
    pub fn clear_lastUpdated(&mut self) {
        self.lastUpdated = 0;
    }

    // Param is passed by value, moved
    pub fn set_lastUpdated(&mut self, v: i64) {
        self.lastUpdated = v;
    }

    // repeated int32 revisions = 3;


    pub fn get_revisions(&self) -> &[i32] {
        &self.revisions
    }
    pub fn clear_revisions(&mut self) {
        self.revisions.clear();
    }

    // Param is passed by value, moved
    pub fn set_revisions(&mut self, v: ::std::vec::Vec<i32>) {
        self.revisions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_revisions(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.revisions
    }

    // Take field
    pub fn take_revisions(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.revisions, ::std::vec::Vec::new())
    }

    // int32 storage_size = 4;


    pub fn get_storage_size(&self) -> i32 {
        self.storage_size
    }
    pub fn clear_storage_size(&mut self) {
        self.storage_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage_size(&mut self, v: i32) {
        self.storage_size = v;
    }

    // uint64 latest_revision = 7;


    pub fn get_latest_revision(&self) -> u64 {
        self.latest_revision
    }
    pub fn clear_latest_revision(&mut self) {
        self.latest_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_revision(&mut self, v: u64) {
        self.latest_revision = v;
    }

    // string storage_uuid = 8;


    pub fn get_storage_uuid(&self) -> &str {
        &self.storage_uuid
    }
    pub fn clear_storage_uuid(&mut self) {
        self.storage_uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_uuid(&mut self, v: ::std::string::String) {
        self.storage_uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.storage_uuid
    }

    // Take field
    pub fn take_storage_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.storage_uuid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CharacterMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lastUpdated = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.revisions)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.storage_size = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.latest_revision = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.storage_uuid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.lastUpdated != 0 {
            my_size += ::protobuf::rt::value_size(5, self.lastUpdated, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.revisions {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.storage_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.storage_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_revision != 0 {
            my_size += ::protobuf::rt::value_size(7, self.latest_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.storage_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.storage_uuid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.lastUpdated != 0 {
            os.write_int64(5, self.lastUpdated)?;
        }
        for v in &self.revisions {
            os.write_int32(3, *v)?;
        };
        if self.storage_size != 0 {
            os.write_int32(4, self.storage_size)?;
        }
        if self.latest_revision != 0 {
            os.write_uint64(7, self.latest_revision)?;
        }
        if !self.storage_uuid.is_empty() {
            os.write_string(8, &self.storage_uuid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CharacterMetadata {
        CharacterMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &CharacterMetadata| { &m.uuid },
                |m: &mut CharacterMetadata| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CharacterMetadata| { &m.name },
                |m: &mut CharacterMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lastUpdated",
                |m: &CharacterMetadata| { &m.lastUpdated },
                |m: &mut CharacterMetadata| { &mut m.lastUpdated },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "revisions",
                |m: &CharacterMetadata| { &m.revisions },
                |m: &mut CharacterMetadata| { &mut m.revisions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "storage_size",
                |m: &CharacterMetadata| { &m.storage_size },
                |m: &mut CharacterMetadata| { &mut m.storage_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "latest_revision",
                |m: &CharacterMetadata| { &m.latest_revision },
                |m: &mut CharacterMetadata| { &mut m.latest_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storage_uuid",
                |m: &CharacterMetadata| { &m.storage_uuid },
                |m: &mut CharacterMetadata| { &mut m.storage_uuid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CharacterMetadata>(
                "CharacterMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CharacterMetadata {
        static instance: ::protobuf::rt::LazyV2<CharacterMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CharacterMetadata::new)
    }
}

impl ::protobuf::Clear for CharacterMetadata {
    fn clear(&mut self) {
        self.uuid.clear();
        self.name.clear();
        self.lastUpdated = 0;
        self.revisions.clear();
        self.storage_size = 0;
        self.latest_revision = 0;
        self.storage_uuid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CharacterMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CharacterMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Character {
    // message fields
    pub uuid: ::std::string::String,
    pub name: ::std::string::String,
    pub descriptor: ::std::string::String,
    pub field_type: ::std::string::String,
    pub focus: ::std::string::String,
    pub color: ::protobuf::SingularPtrField<CharacterColor>,
    pub progress: ::protobuf::SingularPtrField<Progress>,
    pub stats: ::protobuf::SingularPtrField<Stats>,
    pub recovery: ::protobuf::SingularPtrField<Recovery>,
    pub damage: ::protobuf::SingularPtrField<Damage>,
    pub skills: ::protobuf::RepeatedField<Skill>,
    pub abilities: ::protobuf::RepeatedField<Ability>,
    pub cypher_limit: i32,
    pub cyphers: ::protobuf::RepeatedField<Cypher>,
    pub artifacts: ::protobuf::RepeatedField<Artifact>,
    pub money: f64,
    pub inventories: ::protobuf::RepeatedField<Inventory>,
    pub items: ::protobuf::RepeatedField<Item>,
    pub notes: ::protobuf::RepeatedField<Note>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Character {
    fn default() -> &'a Character {
        <Character as ::protobuf::Message>::default_instance()
    }
}

impl Character {
    pub fn new() -> Character {
        ::std::default::Default::default()
    }

    // string uuid = 1;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string descriptor = 3;


    pub fn get_descriptor(&self) -> &str {
        &self.descriptor
    }
    pub fn clear_descriptor(&mut self) {
        self.descriptor.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptor(&mut self, v: ::std::string::String) {
        self.descriptor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_descriptor(&mut self) -> &mut ::std::string::String {
        &mut self.descriptor
    }

    // Take field
    pub fn take_descriptor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.descriptor, ::std::string::String::new())
    }

    // string type = 4;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string focus = 5;


    pub fn get_focus(&self) -> &str {
        &self.focus
    }
    pub fn clear_focus(&mut self) {
        self.focus.clear();
    }

    // Param is passed by value, moved
    pub fn set_focus(&mut self, v: ::std::string::String) {
        self.focus = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_focus(&mut self) -> &mut ::std::string::String {
        &mut self.focus
    }

    // Take field
    pub fn take_focus(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.focus, ::std::string::String::new())
    }

    // .character.CharacterColor color = 17;


    pub fn get_color(&self) -> &CharacterColor {
        self.color.as_ref().unwrap_or_else(|| <CharacterColor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: CharacterColor) {
        self.color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut CharacterColor {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> CharacterColor {
        self.color.take().unwrap_or_else(|| CharacterColor::new())
    }

    // .character.Progress progress = 6;


    pub fn get_progress(&self) -> &Progress {
        self.progress.as_ref().unwrap_or_else(|| <Progress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: Progress) {
        self.progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut Progress {
        if self.progress.is_none() {
            self.progress.set_default();
        }
        self.progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress(&mut self) -> Progress {
        self.progress.take().unwrap_or_else(|| Progress::new())
    }

    // .character.Stats stats = 7;


    pub fn get_stats(&self) -> &Stats {
        self.stats.as_ref().unwrap_or_else(|| <Stats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: Stats) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut Stats {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> Stats {
        self.stats.take().unwrap_or_else(|| Stats::new())
    }

    // .character.Recovery recovery = 8;


    pub fn get_recovery(&self) -> &Recovery {
        self.recovery.as_ref().unwrap_or_else(|| <Recovery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_recovery(&mut self) {
        self.recovery.clear();
    }

    pub fn has_recovery(&self) -> bool {
        self.recovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recovery(&mut self, v: Recovery) {
        self.recovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recovery(&mut self) -> &mut Recovery {
        if self.recovery.is_none() {
            self.recovery.set_default();
        }
        self.recovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_recovery(&mut self) -> Recovery {
        self.recovery.take().unwrap_or_else(|| Recovery::new())
    }

    // .character.Damage damage = 9;


    pub fn get_damage(&self) -> &Damage {
        self.damage.as_ref().unwrap_or_else(|| <Damage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_damage(&mut self) {
        self.damage.clear();
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: Damage) {
        self.damage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_damage(&mut self) -> &mut Damage {
        if self.damage.is_none() {
            self.damage.set_default();
        }
        self.damage.as_mut().unwrap()
    }

    // Take field
    pub fn take_damage(&mut self) -> Damage {
        self.damage.take().unwrap_or_else(|| Damage::new())
    }

    // repeated .character.Skill skills = 10;


    pub fn get_skills(&self) -> &[Skill] {
        &self.skills
    }
    pub fn clear_skills(&mut self) {
        self.skills.clear();
    }

    // Param is passed by value, moved
    pub fn set_skills(&mut self, v: ::protobuf::RepeatedField<Skill>) {
        self.skills = v;
    }

    // Mutable pointer to the field.
    pub fn mut_skills(&mut self) -> &mut ::protobuf::RepeatedField<Skill> {
        &mut self.skills
    }

    // Take field
    pub fn take_skills(&mut self) -> ::protobuf::RepeatedField<Skill> {
        ::std::mem::replace(&mut self.skills, ::protobuf::RepeatedField::new())
    }

    // repeated .character.Ability abilities = 11;


    pub fn get_abilities(&self) -> &[Ability] {
        &self.abilities
    }
    pub fn clear_abilities(&mut self) {
        self.abilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_abilities(&mut self, v: ::protobuf::RepeatedField<Ability>) {
        self.abilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_abilities(&mut self) -> &mut ::protobuf::RepeatedField<Ability> {
        &mut self.abilities
    }

    // Take field
    pub fn take_abilities(&mut self) -> ::protobuf::RepeatedField<Ability> {
        ::std::mem::replace(&mut self.abilities, ::protobuf::RepeatedField::new())
    }

    // int32 cypher_limit = 12;


    pub fn get_cypher_limit(&self) -> i32 {
        self.cypher_limit
    }
    pub fn clear_cypher_limit(&mut self) {
        self.cypher_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_cypher_limit(&mut self, v: i32) {
        self.cypher_limit = v;
    }

    // repeated .character.Cypher cyphers = 13;


    pub fn get_cyphers(&self) -> &[Cypher] {
        &self.cyphers
    }
    pub fn clear_cyphers(&mut self) {
        self.cyphers.clear();
    }

    // Param is passed by value, moved
    pub fn set_cyphers(&mut self, v: ::protobuf::RepeatedField<Cypher>) {
        self.cyphers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cyphers(&mut self) -> &mut ::protobuf::RepeatedField<Cypher> {
        &mut self.cyphers
    }

    // Take field
    pub fn take_cyphers(&mut self) -> ::protobuf::RepeatedField<Cypher> {
        ::std::mem::replace(&mut self.cyphers, ::protobuf::RepeatedField::new())
    }

    // repeated .character.Artifact artifacts = 14;


    pub fn get_artifacts(&self) -> &[Artifact] {
        &self.artifacts
    }
    pub fn clear_artifacts(&mut self) {
        self.artifacts.clear();
    }

    // Param is passed by value, moved
    pub fn set_artifacts(&mut self, v: ::protobuf::RepeatedField<Artifact>) {
        self.artifacts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_artifacts(&mut self) -> &mut ::protobuf::RepeatedField<Artifact> {
        &mut self.artifacts
    }

    // Take field
    pub fn take_artifacts(&mut self) -> ::protobuf::RepeatedField<Artifact> {
        ::std::mem::replace(&mut self.artifacts, ::protobuf::RepeatedField::new())
    }

    // double money = 15;


    pub fn get_money(&self) -> f64 {
        self.money
    }
    pub fn clear_money(&mut self) {
        self.money = 0.;
    }

    // Param is passed by value, moved
    pub fn set_money(&mut self, v: f64) {
        self.money = v;
    }

    // repeated .character.Inventory inventories = 16;


    pub fn get_inventories(&self) -> &[Inventory] {
        &self.inventories
    }
    pub fn clear_inventories(&mut self) {
        self.inventories.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventories(&mut self, v: ::protobuf::RepeatedField<Inventory>) {
        self.inventories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inventories(&mut self) -> &mut ::protobuf::RepeatedField<Inventory> {
        &mut self.inventories
    }

    // Take field
    pub fn take_inventories(&mut self) -> ::protobuf::RepeatedField<Inventory> {
        ::std::mem::replace(&mut self.inventories, ::protobuf::RepeatedField::new())
    }

    // repeated .character.Item items = 18;


    pub fn get_items(&self) -> &[Item] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Item>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Item> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Item> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // repeated .character.Note notes = 19;


    pub fn get_notes(&self) -> &[Note] {
        &self.notes
    }
    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::protobuf::RepeatedField<Note>) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notes(&mut self) -> &mut ::protobuf::RepeatedField<Note> {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::protobuf::RepeatedField<Note> {
        ::std::mem::replace(&mut self.notes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Character {
    fn is_initialized(&self) -> bool {
        for v in &self.color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recovery {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.damage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.skills {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.abilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cyphers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.artifacts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inventories {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.notes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.descriptor)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.focus)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.color)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recovery)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.damage)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.skills)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.abilities)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cypher_limit = tmp;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cyphers)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.artifacts)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.money = tmp;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inventories)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.descriptor.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.descriptor);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.field_type);
        }
        if !self.focus.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.focus);
        }
        if let Some(ref v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.recovery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.damage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.skills {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.cypher_limit != 0 {
            my_size += ::protobuf::rt::value_size(12, self.cypher_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.cyphers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.artifacts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.money != 0. {
            my_size += 9;
        }
        for value in &self.inventories {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.items {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.notes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.descriptor.is_empty() {
            os.write_string(3, &self.descriptor)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(4, &self.field_type)?;
        }
        if !self.focus.is_empty() {
            os.write_string(5, &self.focus)?;
        }
        if let Some(ref v) = self.color.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.progress.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.recovery.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.damage.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.skills {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.abilities {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.cypher_limit != 0 {
            os.write_int32(12, self.cypher_limit)?;
        }
        for v in &self.cyphers {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.artifacts {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.money != 0. {
            os.write_double(15, self.money)?;
        }
        for v in &self.inventories {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.items {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.notes {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Character {
        Character::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &Character| { &m.uuid },
                |m: &mut Character| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Character| { &m.name },
                |m: &mut Character| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptor",
                |m: &Character| { &m.descriptor },
                |m: &mut Character| { &mut m.descriptor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &Character| { &m.field_type },
                |m: &mut Character| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "focus",
                |m: &Character| { &m.focus },
                |m: &mut Character| { &mut m.focus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CharacterColor>>(
                "color",
                |m: &Character| { &m.color },
                |m: &mut Character| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Progress>>(
                "progress",
                |m: &Character| { &m.progress },
                |m: &mut Character| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stats>>(
                "stats",
                |m: &Character| { &m.stats },
                |m: &mut Character| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Recovery>>(
                "recovery",
                |m: &Character| { &m.recovery },
                |m: &mut Character| { &mut m.recovery },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Damage>>(
                "damage",
                |m: &Character| { &m.damage },
                |m: &mut Character| { &mut m.damage },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Skill>>(
                "skills",
                |m: &Character| { &m.skills },
                |m: &mut Character| { &mut m.skills },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ability>>(
                "abilities",
                |m: &Character| { &m.abilities },
                |m: &mut Character| { &mut m.abilities },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cypher_limit",
                |m: &Character| { &m.cypher_limit },
                |m: &mut Character| { &mut m.cypher_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cypher>>(
                "cyphers",
                |m: &Character| { &m.cyphers },
                |m: &mut Character| { &mut m.cyphers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Artifact>>(
                "artifacts",
                |m: &Character| { &m.artifacts },
                |m: &mut Character| { &mut m.artifacts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "money",
                |m: &Character| { &m.money },
                |m: &mut Character| { &mut m.money },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Inventory>>(
                "inventories",
                |m: &Character| { &m.inventories },
                |m: &mut Character| { &mut m.inventories },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Item>>(
                "items",
                |m: &Character| { &m.items },
                |m: &mut Character| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Note>>(
                "notes",
                |m: &Character| { &m.notes },
                |m: &mut Character| { &mut m.notes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Character>(
                "Character",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Character {
        static instance: ::protobuf::rt::LazyV2<Character> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Character::new)
    }
}

impl ::protobuf::Clear for Character {
    fn clear(&mut self) {
        self.uuid.clear();
        self.name.clear();
        self.descriptor.clear();
        self.field_type.clear();
        self.focus.clear();
        self.color.clear();
        self.progress.clear();
        self.stats.clear();
        self.recovery.clear();
        self.damage.clear();
        self.skills.clear();
        self.abilities.clear();
        self.cypher_limit = 0;
        self.cyphers.clear();
        self.artifacts.clear();
        self.money = 0.;
        self.inventories.clear();
        self.items.clear();
        self.notes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Character {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Character {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CharacterColor {
    // message fields
    pub r: i32,
    pub g: i32,
    pub b: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CharacterColor {
    fn default() -> &'a CharacterColor {
        <CharacterColor as ::protobuf::Message>::default_instance()
    }
}

impl CharacterColor {
    pub fn new() -> CharacterColor {
        ::std::default::Default::default()
    }

    // int32 r = 1;


    pub fn get_r(&self) -> i32 {
        self.r
    }
    pub fn clear_r(&mut self) {
        self.r = 0;
    }

    // Param is passed by value, moved
    pub fn set_r(&mut self, v: i32) {
        self.r = v;
    }

    // int32 g = 2;


    pub fn get_g(&self) -> i32 {
        self.g
    }
    pub fn clear_g(&mut self) {
        self.g = 0;
    }

    // Param is passed by value, moved
    pub fn set_g(&mut self, v: i32) {
        self.g = v;
    }

    // int32 b = 3;


    pub fn get_b(&self) -> i32 {
        self.b
    }
    pub fn clear_b(&mut self) {
        self.b = 0;
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: i32) {
        self.b = v;
    }
}

impl ::protobuf::Message for CharacterColor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.r = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.g = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.b = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.r != 0 {
            my_size += ::protobuf::rt::value_size(1, self.r, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.g != 0 {
            my_size += ::protobuf::rt::value_size(2, self.g, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.b != 0 {
            my_size += ::protobuf::rt::value_size(3, self.b, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.r != 0 {
            os.write_int32(1, self.r)?;
        }
        if self.g != 0 {
            os.write_int32(2, self.g)?;
        }
        if self.b != 0 {
            os.write_int32(3, self.b)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CharacterColor {
        CharacterColor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "r",
                |m: &CharacterColor| { &m.r },
                |m: &mut CharacterColor| { &mut m.r },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "g",
                |m: &CharacterColor| { &m.g },
                |m: &mut CharacterColor| { &mut m.g },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "b",
                |m: &CharacterColor| { &m.b },
                |m: &mut CharacterColor| { &mut m.b },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CharacterColor>(
                "CharacterColor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CharacterColor {
        static instance: ::protobuf::rt::LazyV2<CharacterColor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CharacterColor::new)
    }
}

impl ::protobuf::Clear for CharacterColor {
    fn clear(&mut self) {
        self.r = 0;
        self.g = 0;
        self.b = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CharacterColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CharacterColor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdvancementInfo {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdvancementInfo {
    fn default() -> &'a AdvancementInfo {
        <AdvancementInfo as ::protobuf::Message>::default_instance()
    }
}

impl AdvancementInfo {
    pub fn new() -> AdvancementInfo {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AdvancementInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdvancementInfo {
        AdvancementInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AdvancementInfo| { &m.name },
                |m: &mut AdvancementInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &AdvancementInfo| { &m.description },
                |m: &mut AdvancementInfo| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdvancementInfo>(
                "AdvancementInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AdvancementInfo {
        static instance: ::protobuf::rt::LazyV2<AdvancementInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AdvancementInfo::new)
    }
}

impl ::protobuf::Clear for AdvancementInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdvancementInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdvancementInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Advancements {
    // message fields
    pub increaseCapabilities: bool,
    pub moveTowardPerfection: bool,
    pub extraEffort: bool,
    pub skillTraining: bool,
    pub other: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Advancements {
    fn default() -> &'a Advancements {
        <Advancements as ::protobuf::Message>::default_instance()
    }
}

impl Advancements {
    pub fn new() -> Advancements {
        ::std::default::Default::default()
    }

    // bool increaseCapabilities = 1;


    pub fn get_increaseCapabilities(&self) -> bool {
        self.increaseCapabilities
    }
    pub fn clear_increaseCapabilities(&mut self) {
        self.increaseCapabilities = false;
    }

    // Param is passed by value, moved
    pub fn set_increaseCapabilities(&mut self, v: bool) {
        self.increaseCapabilities = v;
    }

    // bool moveTowardPerfection = 2;


    pub fn get_moveTowardPerfection(&self) -> bool {
        self.moveTowardPerfection
    }
    pub fn clear_moveTowardPerfection(&mut self) {
        self.moveTowardPerfection = false;
    }

    // Param is passed by value, moved
    pub fn set_moveTowardPerfection(&mut self, v: bool) {
        self.moveTowardPerfection = v;
    }

    // bool extraEffort = 3;


    pub fn get_extraEffort(&self) -> bool {
        self.extraEffort
    }
    pub fn clear_extraEffort(&mut self) {
        self.extraEffort = false;
    }

    // Param is passed by value, moved
    pub fn set_extraEffort(&mut self, v: bool) {
        self.extraEffort = v;
    }

    // bool skillTraining = 4;


    pub fn get_skillTraining(&self) -> bool {
        self.skillTraining
    }
    pub fn clear_skillTraining(&mut self) {
        self.skillTraining = false;
    }

    // Param is passed by value, moved
    pub fn set_skillTraining(&mut self, v: bool) {
        self.skillTraining = v;
    }

    // bool other = 5;


    pub fn get_other(&self) -> bool {
        self.other
    }
    pub fn clear_other(&mut self) {
        self.other = false;
    }

    // Param is passed by value, moved
    pub fn set_other(&mut self, v: bool) {
        self.other = v;
    }
}

impl ::protobuf::Message for Advancements {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.increaseCapabilities = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.moveTowardPerfection = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.extraEffort = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skillTraining = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.other = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.increaseCapabilities != false {
            my_size += 2;
        }
        if self.moveTowardPerfection != false {
            my_size += 2;
        }
        if self.extraEffort != false {
            my_size += 2;
        }
        if self.skillTraining != false {
            my_size += 2;
        }
        if self.other != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.increaseCapabilities != false {
            os.write_bool(1, self.increaseCapabilities)?;
        }
        if self.moveTowardPerfection != false {
            os.write_bool(2, self.moveTowardPerfection)?;
        }
        if self.extraEffort != false {
            os.write_bool(3, self.extraEffort)?;
        }
        if self.skillTraining != false {
            os.write_bool(4, self.skillTraining)?;
        }
        if self.other != false {
            os.write_bool(5, self.other)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Advancements {
        Advancements::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "increaseCapabilities",
                |m: &Advancements| { &m.increaseCapabilities },
                |m: &mut Advancements| { &mut m.increaseCapabilities },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "moveTowardPerfection",
                |m: &Advancements| { &m.moveTowardPerfection },
                |m: &mut Advancements| { &mut m.moveTowardPerfection },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "extraEffort",
                |m: &Advancements| { &m.extraEffort },
                |m: &mut Advancements| { &mut m.extraEffort },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "skillTraining",
                |m: &Advancements| { &m.skillTraining },
                |m: &mut Advancements| { &mut m.skillTraining },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "other",
                |m: &Advancements| { &m.other },
                |m: &mut Advancements| { &mut m.other },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Advancements>(
                "Advancements",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Advancements {
        static instance: ::protobuf::rt::LazyV2<Advancements> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Advancements::new)
    }
}

impl ::protobuf::Clear for Advancements {
    fn clear(&mut self) {
        self.increaseCapabilities = false;
        self.moveTowardPerfection = false;
        self.extraEffort = false;
        self.skillTraining = false;
        self.other = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Advancements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Advancements {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Progress {
    // message fields
    pub tier: i32,
    pub free_xp: i32,
    pub total_xp: i32,
    pub max_effort: i32,
    pub advancements: ::protobuf::SingularPtrField<Advancements>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Progress {
    fn default() -> &'a Progress {
        <Progress as ::protobuf::Message>::default_instance()
    }
}

impl Progress {
    pub fn new() -> Progress {
        ::std::default::Default::default()
    }

    // int32 tier = 1;


    pub fn get_tier(&self) -> i32 {
        self.tier
    }
    pub fn clear_tier(&mut self) {
        self.tier = 0;
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: i32) {
        self.tier = v;
    }

    // int32 free_xp = 2;


    pub fn get_free_xp(&self) -> i32 {
        self.free_xp
    }
    pub fn clear_free_xp(&mut self) {
        self.free_xp = 0;
    }

    // Param is passed by value, moved
    pub fn set_free_xp(&mut self, v: i32) {
        self.free_xp = v;
    }

    // int32 total_xp = 3;


    pub fn get_total_xp(&self) -> i32 {
        self.total_xp
    }
    pub fn clear_total_xp(&mut self) {
        self.total_xp = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_xp(&mut self, v: i32) {
        self.total_xp = v;
    }

    // int32 max_effort = 4;


    pub fn get_max_effort(&self) -> i32 {
        self.max_effort
    }
    pub fn clear_max_effort(&mut self) {
        self.max_effort = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_effort(&mut self, v: i32) {
        self.max_effort = v;
    }

    // .character.Advancements advancements = 5;


    pub fn get_advancements(&self) -> &Advancements {
        self.advancements.as_ref().unwrap_or_else(|| <Advancements as ::protobuf::Message>::default_instance())
    }
    pub fn clear_advancements(&mut self) {
        self.advancements.clear();
    }

    pub fn has_advancements(&self) -> bool {
        self.advancements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_advancements(&mut self, v: Advancements) {
        self.advancements = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_advancements(&mut self) -> &mut Advancements {
        if self.advancements.is_none() {
            self.advancements.set_default();
        }
        self.advancements.as_mut().unwrap()
    }

    // Take field
    pub fn take_advancements(&mut self) -> Advancements {
        self.advancements.take().unwrap_or_else(|| Advancements::new())
    }
}

impl ::protobuf::Message for Progress {
    fn is_initialized(&self) -> bool {
        for v in &self.advancements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tier = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.free_xp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_xp = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_effort = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.advancements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tier != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tier, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.free_xp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.free_xp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_xp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_xp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_effort != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_effort, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.advancements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tier != 0 {
            os.write_int32(1, self.tier)?;
        }
        if self.free_xp != 0 {
            os.write_int32(2, self.free_xp)?;
        }
        if self.total_xp != 0 {
            os.write_int32(3, self.total_xp)?;
        }
        if self.max_effort != 0 {
            os.write_int32(4, self.max_effort)?;
        }
        if let Some(ref v) = self.advancements.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Progress {
        Progress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tier",
                |m: &Progress| { &m.tier },
                |m: &mut Progress| { &mut m.tier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "free_xp",
                |m: &Progress| { &m.free_xp },
                |m: &mut Progress| { &mut m.free_xp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_xp",
                |m: &Progress| { &m.total_xp },
                |m: &mut Progress| { &mut m.total_xp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_effort",
                |m: &Progress| { &m.max_effort },
                |m: &mut Progress| { &mut m.max_effort },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Advancements>>(
                "advancements",
                |m: &Progress| { &m.advancements },
                |m: &mut Progress| { &mut m.advancements },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Progress>(
                "Progress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Progress {
        static instance: ::protobuf::rt::LazyV2<Progress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Progress::new)
    }
}

impl ::protobuf::Clear for Progress {
    fn clear(&mut self) {
        self.tier = 0;
        self.free_xp = 0;
        self.total_xp = 0;
        self.max_effort = 0;
        self.advancements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Progress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Progress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stat {
    // message fields
    pub field_type: PoolType,
    pub cap: i32,
    pub pool: i32,
    pub edge: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Stat {
    fn default() -> &'a Stat {
        <Stat as ::protobuf::Message>::default_instance()
    }
}

impl Stat {
    pub fn new() -> Stat {
        ::std::default::Default::default()
    }

    // .character.PoolType type = 1;


    pub fn get_field_type(&self) -> PoolType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PoolType::intellect;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PoolType) {
        self.field_type = v;
    }

    // int32 cap = 2;


    pub fn get_cap(&self) -> i32 {
        self.cap
    }
    pub fn clear_cap(&mut self) {
        self.cap = 0;
    }

    // Param is passed by value, moved
    pub fn set_cap(&mut self, v: i32) {
        self.cap = v;
    }

    // int32 pool = 3;


    pub fn get_pool(&self) -> i32 {
        self.pool
    }
    pub fn clear_pool(&mut self) {
        self.pool = 0;
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: i32) {
        self.pool = v;
    }

    // int32 edge = 4;


    pub fn get_edge(&self) -> i32 {
        self.edge
    }
    pub fn clear_edge(&mut self) {
        self.edge = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge(&mut self, v: i32) {
        self.edge = v;
    }
}

impl ::protobuf::Message for Stat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cap = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pool = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.edge = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != PoolType::intellect {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.cap != 0 {
            my_size += ::protobuf::rt::value_size(2, self.cap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pool != 0 {
            my_size += ::protobuf::rt::value_size(3, self.pool, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.edge != 0 {
            my_size += ::protobuf::rt::value_size(4, self.edge, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != PoolType::intellect {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.cap != 0 {
            os.write_int32(2, self.cap)?;
        }
        if self.pool != 0 {
            os.write_int32(3, self.pool)?;
        }
        if self.edge != 0 {
            os.write_int32(4, self.edge)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stat {
        Stat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PoolType>>(
                "type",
                |m: &Stat| { &m.field_type },
                |m: &mut Stat| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cap",
                |m: &Stat| { &m.cap },
                |m: &mut Stat| { &mut m.cap },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pool",
                |m: &Stat| { &m.pool },
                |m: &mut Stat| { &mut m.pool },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "edge",
                |m: &Stat| { &m.edge },
                |m: &mut Stat| { &mut m.edge },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Stat>(
                "Stat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Stat {
        static instance: ::protobuf::rt::LazyV2<Stat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Stat::new)
    }
}

impl ::protobuf::Clear for Stat {
    fn clear(&mut self) {
        self.field_type = PoolType::intellect;
        self.cap = 0;
        self.pool = 0;
        self.edge = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stats {
    // message fields
    pub intellect: ::protobuf::SingularPtrField<Stat>,
    pub speed: ::protobuf::SingularPtrField<Stat>,
    pub might: ::protobuf::SingularPtrField<Stat>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Stats {
    fn default() -> &'a Stats {
        <Stats as ::protobuf::Message>::default_instance()
    }
}

impl Stats {
    pub fn new() -> Stats {
        ::std::default::Default::default()
    }

    // .character.Stat intellect = 1;


    pub fn get_intellect(&self) -> &Stat {
        self.intellect.as_ref().unwrap_or_else(|| <Stat as ::protobuf::Message>::default_instance())
    }
    pub fn clear_intellect(&mut self) {
        self.intellect.clear();
    }

    pub fn has_intellect(&self) -> bool {
        self.intellect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intellect(&mut self, v: Stat) {
        self.intellect = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_intellect(&mut self) -> &mut Stat {
        if self.intellect.is_none() {
            self.intellect.set_default();
        }
        self.intellect.as_mut().unwrap()
    }

    // Take field
    pub fn take_intellect(&mut self) -> Stat {
        self.intellect.take().unwrap_or_else(|| Stat::new())
    }

    // .character.Stat speed = 2;


    pub fn get_speed(&self) -> &Stat {
        self.speed.as_ref().unwrap_or_else(|| <Stat as ::protobuf::Message>::default_instance())
    }
    pub fn clear_speed(&mut self) {
        self.speed.clear();
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: Stat) {
        self.speed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_speed(&mut self) -> &mut Stat {
        if self.speed.is_none() {
            self.speed.set_default();
        }
        self.speed.as_mut().unwrap()
    }

    // Take field
    pub fn take_speed(&mut self) -> Stat {
        self.speed.take().unwrap_or_else(|| Stat::new())
    }

    // .character.Stat might = 3;


    pub fn get_might(&self) -> &Stat {
        self.might.as_ref().unwrap_or_else(|| <Stat as ::protobuf::Message>::default_instance())
    }
    pub fn clear_might(&mut self) {
        self.might.clear();
    }

    pub fn has_might(&self) -> bool {
        self.might.is_some()
    }

    // Param is passed by value, moved
    pub fn set_might(&mut self, v: Stat) {
        self.might = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_might(&mut self) -> &mut Stat {
        if self.might.is_none() {
            self.might.set_default();
        }
        self.might.as_mut().unwrap()
    }

    // Take field
    pub fn take_might(&mut self) -> Stat {
        self.might.take().unwrap_or_else(|| Stat::new())
    }
}

impl ::protobuf::Message for Stats {
    fn is_initialized(&self) -> bool {
        for v in &self.intellect {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.might {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.intellect)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.speed)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.might)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.intellect.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.speed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.might.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.intellect.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.speed.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.might.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stats {
        Stats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stat>>(
                "intellect",
                |m: &Stats| { &m.intellect },
                |m: &mut Stats| { &mut m.intellect },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stat>>(
                "speed",
                |m: &Stats| { &m.speed },
                |m: &mut Stats| { &mut m.speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stat>>(
                "might",
                |m: &Stats| { &m.might },
                |m: &mut Stats| { &mut m.might },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Stats>(
                "Stats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Stats {
        static instance: ::protobuf::rt::LazyV2<Stats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Stats::new)
    }
}

impl ::protobuf::Clear for Stats {
    fn clear(&mut self) {
        self.intellect.clear();
        self.speed.clear();
        self.might.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Recovery {
    // message fields
    pub bonus: i32,
    pub one_action: bool,
    pub ten_minutes: bool,
    pub one_hour: bool,
    pub ten_hours: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Recovery {
    fn default() -> &'a Recovery {
        <Recovery as ::protobuf::Message>::default_instance()
    }
}

impl Recovery {
    pub fn new() -> Recovery {
        ::std::default::Default::default()
    }

    // int32 bonus = 1;


    pub fn get_bonus(&self) -> i32 {
        self.bonus
    }
    pub fn clear_bonus(&mut self) {
        self.bonus = 0;
    }

    // Param is passed by value, moved
    pub fn set_bonus(&mut self, v: i32) {
        self.bonus = v;
    }

    // bool one_action = 2;


    pub fn get_one_action(&self) -> bool {
        self.one_action
    }
    pub fn clear_one_action(&mut self) {
        self.one_action = false;
    }

    // Param is passed by value, moved
    pub fn set_one_action(&mut self, v: bool) {
        self.one_action = v;
    }

    // bool ten_minutes = 3;


    pub fn get_ten_minutes(&self) -> bool {
        self.ten_minutes
    }
    pub fn clear_ten_minutes(&mut self) {
        self.ten_minutes = false;
    }

    // Param is passed by value, moved
    pub fn set_ten_minutes(&mut self, v: bool) {
        self.ten_minutes = v;
    }

    // bool one_hour = 4;


    pub fn get_one_hour(&self) -> bool {
        self.one_hour
    }
    pub fn clear_one_hour(&mut self) {
        self.one_hour = false;
    }

    // Param is passed by value, moved
    pub fn set_one_hour(&mut self, v: bool) {
        self.one_hour = v;
    }

    // bool ten_hours = 5;


    pub fn get_ten_hours(&self) -> bool {
        self.ten_hours
    }
    pub fn clear_ten_hours(&mut self) {
        self.ten_hours = false;
    }

    // Param is passed by value, moved
    pub fn set_ten_hours(&mut self, v: bool) {
        self.ten_hours = v;
    }
}

impl ::protobuf::Message for Recovery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bonus = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.one_action = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ten_minutes = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.one_hour = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ten_hours = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bonus != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bonus, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.one_action != false {
            my_size += 2;
        }
        if self.ten_minutes != false {
            my_size += 2;
        }
        if self.one_hour != false {
            my_size += 2;
        }
        if self.ten_hours != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bonus != 0 {
            os.write_int32(1, self.bonus)?;
        }
        if self.one_action != false {
            os.write_bool(2, self.one_action)?;
        }
        if self.ten_minutes != false {
            os.write_bool(3, self.ten_minutes)?;
        }
        if self.one_hour != false {
            os.write_bool(4, self.one_hour)?;
        }
        if self.ten_hours != false {
            os.write_bool(5, self.ten_hours)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Recovery {
        Recovery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bonus",
                |m: &Recovery| { &m.bonus },
                |m: &mut Recovery| { &mut m.bonus },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "one_action",
                |m: &Recovery| { &m.one_action },
                |m: &mut Recovery| { &mut m.one_action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ten_minutes",
                |m: &Recovery| { &m.ten_minutes },
                |m: &mut Recovery| { &mut m.ten_minutes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "one_hour",
                |m: &Recovery| { &m.one_hour },
                |m: &mut Recovery| { &mut m.one_hour },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ten_hours",
                |m: &Recovery| { &m.ten_hours },
                |m: &mut Recovery| { &mut m.ten_hours },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Recovery>(
                "Recovery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Recovery {
        static instance: ::protobuf::rt::LazyV2<Recovery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Recovery::new)
    }
}

impl ::protobuf::Clear for Recovery {
    fn clear(&mut self) {
        self.bonus = 0;
        self.one_action = false;
        self.ten_minutes = false;
        self.one_hour = false;
        self.ten_hours = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Recovery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Recovery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Damage {
    // message fields
    pub impaired: bool,
    pub debilitated: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Damage {
    fn default() -> &'a Damage {
        <Damage as ::protobuf::Message>::default_instance()
    }
}

impl Damage {
    pub fn new() -> Damage {
        ::std::default::Default::default()
    }

    // bool impaired = 1;


    pub fn get_impaired(&self) -> bool {
        self.impaired
    }
    pub fn clear_impaired(&mut self) {
        self.impaired = false;
    }

    // Param is passed by value, moved
    pub fn set_impaired(&mut self, v: bool) {
        self.impaired = v;
    }

    // bool debilitated = 2;


    pub fn get_debilitated(&self) -> bool {
        self.debilitated
    }
    pub fn clear_debilitated(&mut self) {
        self.debilitated = false;
    }

    // Param is passed by value, moved
    pub fn set_debilitated(&mut self, v: bool) {
        self.debilitated = v;
    }
}

impl ::protobuf::Message for Damage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.impaired = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.debilitated = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.impaired != false {
            my_size += 2;
        }
        if self.debilitated != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.impaired != false {
            os.write_bool(1, self.impaired)?;
        }
        if self.debilitated != false {
            os.write_bool(2, self.debilitated)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Damage {
        Damage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "impaired",
                |m: &Damage| { &m.impaired },
                |m: &mut Damage| { &mut m.impaired },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "debilitated",
                |m: &Damage| { &m.debilitated },
                |m: &mut Damage| { &mut m.debilitated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Damage>(
                "Damage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Damage {
        static instance: ::protobuf::rt::LazyV2<Damage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Damage::new)
    }
}

impl ::protobuf::Clear for Damage {
    fn clear(&mut self) {
        self.impaired = false;
        self.debilitated = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Damage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Damage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Skill {
    // message fields
    pub uuid: ::std::string::String,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub field_type: PoolType,
    pub level: SkillLevel,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Skill {
    fn default() -> &'a Skill {
        <Skill as ::protobuf::Message>::default_instance()
    }
}

impl Skill {
    pub fn new() -> Skill {
        ::std::default::Default::default()
    }

    // string uuid = 1;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .character.PoolType type = 4;


    pub fn get_field_type(&self) -> PoolType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PoolType::intellect;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PoolType) {
        self.field_type = v;
    }

    // .character.SkillLevel level = 5;


    pub fn get_level(&self) -> SkillLevel {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = SkillLevel::specialized;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: SkillLevel) {
        self.level = v;
    }
}

impl ::protobuf::Message for Skill {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.level, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.field_type != PoolType::intellect {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        if self.level != SkillLevel::specialized {
            my_size += ::protobuf::rt::enum_size(5, self.level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.field_type != PoolType::intellect {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.level != SkillLevel::specialized {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.level))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Skill {
        Skill::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &Skill| { &m.uuid },
                |m: &mut Skill| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Skill| { &m.name },
                |m: &mut Skill| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Skill| { &m.description },
                |m: &mut Skill| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PoolType>>(
                "type",
                |m: &Skill| { &m.field_type },
                |m: &mut Skill| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SkillLevel>>(
                "level",
                |m: &Skill| { &m.level },
                |m: &mut Skill| { &mut m.level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Skill>(
                "Skill",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Skill {
        static instance: ::protobuf::rt::LazyV2<Skill> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Skill::new)
    }
}

impl ::protobuf::Clear for Skill {
    fn clear(&mut self) {
        self.uuid.clear();
        self.name.clear();
        self.description.clear();
        self.field_type = PoolType::intellect;
        self.level = SkillLevel::specialized;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Skill {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Skill {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ability {
    // message fields
    pub uuid: ::std::string::String,
    pub name: ::std::string::String,
    pub cost: ::std::string::String,
    pub field_type: PoolType,
    pub enabler: bool,
    pub description: ::std::string::String,
    pub short_description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ability {
    fn default() -> &'a Ability {
        <Ability as ::protobuf::Message>::default_instance()
    }
}

impl Ability {
    pub fn new() -> Ability {
        ::std::default::Default::default()
    }

    // string uuid = 1;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string cost = 3;


    pub fn get_cost(&self) -> &str {
        &self.cost
    }
    pub fn clear_cost(&mut self) {
        self.cost.clear();
    }

    // Param is passed by value, moved
    pub fn set_cost(&mut self, v: ::std::string::String) {
        self.cost = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cost(&mut self) -> &mut ::std::string::String {
        &mut self.cost
    }

    // Take field
    pub fn take_cost(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cost, ::std::string::String::new())
    }

    // .character.PoolType type = 4;


    pub fn get_field_type(&self) -> PoolType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PoolType::intellect;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PoolType) {
        self.field_type = v;
    }

    // bool enabler = 5;


    pub fn get_enabler(&self) -> bool {
        self.enabler
    }
    pub fn clear_enabler(&mut self) {
        self.enabler = false;
    }

    // Param is passed by value, moved
    pub fn set_enabler(&mut self, v: bool) {
        self.enabler = v;
    }

    // string description = 6;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string short_description = 7;


    pub fn get_short_description(&self) -> &str {
        &self.short_description
    }
    pub fn clear_short_description(&mut self) {
        self.short_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_short_description(&mut self, v: ::std::string::String) {
        self.short_description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_short_description(&mut self) -> &mut ::std::string::String {
        &mut self.short_description
    }

    // Take field
    pub fn take_short_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.short_description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Ability {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cost)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabler = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.short_description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.cost.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cost);
        }
        if self.field_type != PoolType::intellect {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        if self.enabler != false {
            my_size += 2;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        if !self.short_description.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.short_description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.cost.is_empty() {
            os.write_string(3, &self.cost)?;
        }
        if self.field_type != PoolType::intellect {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.enabler != false {
            os.write_bool(5, self.enabler)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        if !self.short_description.is_empty() {
            os.write_string(7, &self.short_description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ability {
        Ability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &Ability| { &m.uuid },
                |m: &mut Ability| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Ability| { &m.name },
                |m: &mut Ability| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cost",
                |m: &Ability| { &m.cost },
                |m: &mut Ability| { &mut m.cost },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PoolType>>(
                "type",
                |m: &Ability| { &m.field_type },
                |m: &mut Ability| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabler",
                |m: &Ability| { &m.enabler },
                |m: &mut Ability| { &mut m.enabler },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Ability| { &m.description },
                |m: &mut Ability| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "short_description",
                |m: &Ability| { &m.short_description },
                |m: &mut Ability| { &mut m.short_description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ability>(
                "Ability",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ability {
        static instance: ::protobuf::rt::LazyV2<Ability> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ability::new)
    }
}

impl ::protobuf::Clear for Ability {
    fn clear(&mut self) {
        self.uuid.clear();
        self.name.clear();
        self.cost.clear();
        self.field_type = PoolType::intellect;
        self.enabler = false;
        self.description.clear();
        self.short_description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ability {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cypher {
    // message fields
    pub uuid: ::std::string::String,
    pub name: ::std::string::String,
    pub level: ::std::string::String,
    pub short_description: ::std::string::String,
    pub effect: ::std::string::String,
    pub active: bool,
    pub depletion: ::std::string::String,
    pub internal: ::std::string::String,
    pub wearable: ::std::string::String,
    pub usable: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cypher {
    fn default() -> &'a Cypher {
        <Cypher as ::protobuf::Message>::default_instance()
    }
}

impl Cypher {
    pub fn new() -> Cypher {
        ::std::default::Default::default()
    }

    // string uuid = 1;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string level = 3;


    pub fn get_level(&self) -> &str {
        &self.level
    }
    pub fn clear_level(&mut self) {
        self.level.clear();
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: ::std::string::String) {
        self.level = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level(&mut self) -> &mut ::std::string::String {
        &mut self.level
    }

    // Take field
    pub fn take_level(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.level, ::std::string::String::new())
    }

    // string short_description = 4;


    pub fn get_short_description(&self) -> &str {
        &self.short_description
    }
    pub fn clear_short_description(&mut self) {
        self.short_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_short_description(&mut self, v: ::std::string::String) {
        self.short_description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_short_description(&mut self) -> &mut ::std::string::String {
        &mut self.short_description
    }

    // Take field
    pub fn take_short_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.short_description, ::std::string::String::new())
    }

    // string effect = 5;


    pub fn get_effect(&self) -> &str {
        &self.effect
    }
    pub fn clear_effect(&mut self) {
        self.effect.clear();
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        &mut self.effect
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.effect, ::std::string::String::new())
    }

    // bool active = 6;


    pub fn get_active(&self) -> bool {
        self.active
    }
    pub fn clear_active(&mut self) {
        self.active = false;
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = v;
    }

    // string depletion = 7;


    pub fn get_depletion(&self) -> &str {
        &self.depletion
    }
    pub fn clear_depletion(&mut self) {
        self.depletion.clear();
    }

    // Param is passed by value, moved
    pub fn set_depletion(&mut self, v: ::std::string::String) {
        self.depletion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_depletion(&mut self) -> &mut ::std::string::String {
        &mut self.depletion
    }

    // Take field
    pub fn take_depletion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.depletion, ::std::string::String::new())
    }

    // string internal = 8;


    pub fn get_internal(&self) -> &str {
        &self.internal
    }
    pub fn clear_internal(&mut self) {
        self.internal.clear();
    }

    // Param is passed by value, moved
    pub fn set_internal(&mut self, v: ::std::string::String) {
        self.internal = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_internal(&mut self) -> &mut ::std::string::String {
        &mut self.internal
    }

    // Take field
    pub fn take_internal(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.internal, ::std::string::String::new())
    }

    // string wearable = 9;


    pub fn get_wearable(&self) -> &str {
        &self.wearable
    }
    pub fn clear_wearable(&mut self) {
        self.wearable.clear();
    }

    // Param is passed by value, moved
    pub fn set_wearable(&mut self, v: ::std::string::String) {
        self.wearable = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wearable(&mut self) -> &mut ::std::string::String {
        &mut self.wearable
    }

    // Take field
    pub fn take_wearable(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wearable, ::std::string::String::new())
    }

    // string usable = 10;


    pub fn get_usable(&self) -> &str {
        &self.usable
    }
    pub fn clear_usable(&mut self) {
        self.usable.clear();
    }

    // Param is passed by value, moved
    pub fn set_usable(&mut self, v: ::std::string::String) {
        self.usable = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usable(&mut self) -> &mut ::std::string::String {
        &mut self.usable
    }

    // Take field
    pub fn take_usable(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.usable, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Cypher {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.level)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.short_description)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.effect)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.depletion)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.internal)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wearable)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.usable)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.level.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.level);
        }
        if !self.short_description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.short_description);
        }
        if !self.effect.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.effect);
        }
        if self.active != false {
            my_size += 2;
        }
        if !self.depletion.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.depletion);
        }
        if !self.internal.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.internal);
        }
        if !self.wearable.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.wearable);
        }
        if !self.usable.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.usable);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.level.is_empty() {
            os.write_string(3, &self.level)?;
        }
        if !self.short_description.is_empty() {
            os.write_string(4, &self.short_description)?;
        }
        if !self.effect.is_empty() {
            os.write_string(5, &self.effect)?;
        }
        if self.active != false {
            os.write_bool(6, self.active)?;
        }
        if !self.depletion.is_empty() {
            os.write_string(7, &self.depletion)?;
        }
        if !self.internal.is_empty() {
            os.write_string(8, &self.internal)?;
        }
        if !self.wearable.is_empty() {
            os.write_string(9, &self.wearable)?;
        }
        if !self.usable.is_empty() {
            os.write_string(10, &self.usable)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cypher {
        Cypher::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &Cypher| { &m.uuid },
                |m: &mut Cypher| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Cypher| { &m.name },
                |m: &mut Cypher| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "level",
                |m: &Cypher| { &m.level },
                |m: &mut Cypher| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "short_description",
                |m: &Cypher| { &m.short_description },
                |m: &mut Cypher| { &mut m.short_description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "effect",
                |m: &Cypher| { &m.effect },
                |m: &mut Cypher| { &mut m.effect },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "active",
                |m: &Cypher| { &m.active },
                |m: &mut Cypher| { &mut m.active },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "depletion",
                |m: &Cypher| { &m.depletion },
                |m: &mut Cypher| { &mut m.depletion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "internal",
                |m: &Cypher| { &m.internal },
                |m: &mut Cypher| { &mut m.internal },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "wearable",
                |m: &Cypher| { &m.wearable },
                |m: &mut Cypher| { &mut m.wearable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "usable",
                |m: &Cypher| { &m.usable },
                |m: &mut Cypher| { &mut m.usable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cypher>(
                "Cypher",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cypher {
        static instance: ::protobuf::rt::LazyV2<Cypher> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cypher::new)
    }
}

impl ::protobuf::Clear for Cypher {
    fn clear(&mut self) {
        self.uuid.clear();
        self.name.clear();
        self.level.clear();
        self.short_description.clear();
        self.effect.clear();
        self.active = false;
        self.depletion.clear();
        self.internal.clear();
        self.wearable.clear();
        self.usable.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cypher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cypher {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Artifact {
    // message fields
    pub uuid: ::std::string::String,
    pub name: ::std::string::String,
    pub level: ::std::string::String,
    pub short_description: ::std::string::String,
    pub effect: ::std::string::String,
    pub active: bool,
    pub depletion: ::std::string::String,
    pub form: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Artifact {
    fn default() -> &'a Artifact {
        <Artifact as ::protobuf::Message>::default_instance()
    }
}

impl Artifact {
    pub fn new() -> Artifact {
        ::std::default::Default::default()
    }

    // string uuid = 1;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string level = 3;


    pub fn get_level(&self) -> &str {
        &self.level
    }
    pub fn clear_level(&mut self) {
        self.level.clear();
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: ::std::string::String) {
        self.level = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level(&mut self) -> &mut ::std::string::String {
        &mut self.level
    }

    // Take field
    pub fn take_level(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.level, ::std::string::String::new())
    }

    // string short_description = 4;


    pub fn get_short_description(&self) -> &str {
        &self.short_description
    }
    pub fn clear_short_description(&mut self) {
        self.short_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_short_description(&mut self, v: ::std::string::String) {
        self.short_description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_short_description(&mut self) -> &mut ::std::string::String {
        &mut self.short_description
    }

    // Take field
    pub fn take_short_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.short_description, ::std::string::String::new())
    }

    // string effect = 5;


    pub fn get_effect(&self) -> &str {
        &self.effect
    }
    pub fn clear_effect(&mut self) {
        self.effect.clear();
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        &mut self.effect
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.effect, ::std::string::String::new())
    }

    // bool active = 6;


    pub fn get_active(&self) -> bool {
        self.active
    }
    pub fn clear_active(&mut self) {
        self.active = false;
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = v;
    }

    // string depletion = 7;


    pub fn get_depletion(&self) -> &str {
        &self.depletion
    }
    pub fn clear_depletion(&mut self) {
        self.depletion.clear();
    }

    // Param is passed by value, moved
    pub fn set_depletion(&mut self, v: ::std::string::String) {
        self.depletion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_depletion(&mut self) -> &mut ::std::string::String {
        &mut self.depletion
    }

    // Take field
    pub fn take_depletion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.depletion, ::std::string::String::new())
    }

    // string form = 8;


    pub fn get_form(&self) -> &str {
        &self.form
    }
    pub fn clear_form(&mut self) {
        self.form.clear();
    }

    // Param is passed by value, moved
    pub fn set_form(&mut self, v: ::std::string::String) {
        self.form = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_form(&mut self) -> &mut ::std::string::String {
        &mut self.form
    }

    // Take field
    pub fn take_form(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.form, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Artifact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.level)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.short_description)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.effect)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.depletion)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.form)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.level.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.level);
        }
        if !self.short_description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.short_description);
        }
        if !self.effect.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.effect);
        }
        if self.active != false {
            my_size += 2;
        }
        if !self.depletion.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.depletion);
        }
        if !self.form.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.form);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.level.is_empty() {
            os.write_string(3, &self.level)?;
        }
        if !self.short_description.is_empty() {
            os.write_string(4, &self.short_description)?;
        }
        if !self.effect.is_empty() {
            os.write_string(5, &self.effect)?;
        }
        if self.active != false {
            os.write_bool(6, self.active)?;
        }
        if !self.depletion.is_empty() {
            os.write_string(7, &self.depletion)?;
        }
        if !self.form.is_empty() {
            os.write_string(8, &self.form)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Artifact {
        Artifact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &Artifact| { &m.uuid },
                |m: &mut Artifact| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Artifact| { &m.name },
                |m: &mut Artifact| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "level",
                |m: &Artifact| { &m.level },
                |m: &mut Artifact| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "short_description",
                |m: &Artifact| { &m.short_description },
                |m: &mut Artifact| { &mut m.short_description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "effect",
                |m: &Artifact| { &m.effect },
                |m: &mut Artifact| { &mut m.effect },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "active",
                |m: &Artifact| { &m.active },
                |m: &mut Artifact| { &mut m.active },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "depletion",
                |m: &Artifact| { &m.depletion },
                |m: &mut Artifact| { &mut m.depletion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "form",
                |m: &Artifact| { &m.form },
                |m: &mut Artifact| { &mut m.form },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Artifact>(
                "Artifact",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Artifact {
        static instance: ::protobuf::rt::LazyV2<Artifact> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Artifact::new)
    }
}

impl ::protobuf::Clear for Artifact {
    fn clear(&mut self) {
        self.uuid.clear();
        self.name.clear();
        self.level.clear();
        self.short_description.clear();
        self.effect.clear();
        self.active = false;
        self.depletion.clear();
        self.form.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Artifact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Artifact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Inventory {
    // message fields
    pub uuid: ::std::string::String,
    pub name: ::std::string::String,
    pub order: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Inventory {
    fn default() -> &'a Inventory {
        <Inventory as ::protobuf::Message>::default_instance()
    }
}

impl Inventory {
    pub fn new() -> Inventory {
        ::std::default::Default::default()
    }

    // string uuid = 1;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int32 order = 4;


    pub fn get_order(&self) -> i32 {
        self.order
    }
    pub fn clear_order(&mut self) {
        self.order = 0;
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: i32) {
        self.order = v;
    }
}

impl ::protobuf::Message for Inventory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.order = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.order != 0 {
            my_size += ::protobuf::rt::value_size(4, self.order, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.order != 0 {
            os.write_int32(4, self.order)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Inventory {
        Inventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &Inventory| { &m.uuid },
                |m: &mut Inventory| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Inventory| { &m.name },
                |m: &mut Inventory| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "order",
                |m: &Inventory| { &m.order },
                |m: &mut Inventory| { &mut m.order },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Inventory>(
                "Inventory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Inventory {
        static instance: ::protobuf::rt::LazyV2<Inventory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Inventory::new)
    }
}

impl ::protobuf::Clear for Inventory {
    fn clear(&mut self) {
        self.uuid.clear();
        self.name.clear();
        self.order = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Inventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Inventory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ItemPath {
    // message fields
    pub inventory: ::std::string::String,
    pub parent: ::std::string::String,
    pub field_self: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ItemPath {
    fn default() -> &'a ItemPath {
        <ItemPath as ::protobuf::Message>::default_instance()
    }
}

impl ItemPath {
    pub fn new() -> ItemPath {
        ::std::default::Default::default()
    }

    // string inventory = 1;


    pub fn get_inventory(&self) -> &str {
        &self.inventory
    }
    pub fn clear_inventory(&mut self) {
        self.inventory.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: ::std::string::String) {
        self.inventory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inventory(&mut self) -> &mut ::std::string::String {
        &mut self.inventory
    }

    // Take field
    pub fn take_inventory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.inventory, ::std::string::String::new())
    }

    // string parent = 2;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string self = 3;


    pub fn get_field_self(&self) -> &str {
        &self.field_self
    }
    pub fn clear_field_self(&mut self) {
        self.field_self.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_self(&mut self, v: ::std::string::String) {
        self.field_self = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_self(&mut self) -> &mut ::std::string::String {
        &mut self.field_self
    }

    // Take field
    pub fn take_field_self(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_self, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ItemPath {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.inventory)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_self)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.inventory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.inventory);
        }
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.parent);
        }
        if !self.field_self.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_self);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.inventory.is_empty() {
            os.write_string(1, &self.inventory)?;
        }
        if !self.parent.is_empty() {
            os.write_string(2, &self.parent)?;
        }
        if !self.field_self.is_empty() {
            os.write_string(3, &self.field_self)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ItemPath {
        ItemPath::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "inventory",
                |m: &ItemPath| { &m.inventory },
                |m: &mut ItemPath| { &mut m.inventory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ItemPath| { &m.parent },
                |m: &mut ItemPath| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "self",
                |m: &ItemPath| { &m.field_self },
                |m: &mut ItemPath| { &mut m.field_self },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ItemPath>(
                "ItemPath",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ItemPath {
        static instance: ::protobuf::rt::LazyV2<ItemPath> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ItemPath::new)
    }
}

impl ::protobuf::Clear for ItemPath {
    fn clear(&mut self) {
        self.inventory.clear();
        self.parent.clear();
        self.field_self.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ItemPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ItemPath {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Item {
    // message fields
    pub path: ::protobuf::SingularPtrField<ItemPath>,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub short_description: ::std::string::String,
    pub types: ::std::vec::Vec<ItemType>,
    pub amount: f64,
    pub value: f64,
    // message oneof groups
    pub _sub_item_type: ::std::option::Option<Item_oneof__sub_item_type>,
    pub _armor: ::std::option::Option<Item_oneof__armor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Item {
    fn default() -> &'a Item {
        <Item as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Item_oneof__sub_item_type {
    sub_item_type(ItemType),
}

#[derive(Clone,PartialEq,Debug)]
pub enum Item_oneof__armor {
    armor(i32),
}

impl Item {
    pub fn new() -> Item {
        ::std::default::Default::default()
    }

    // .character.ItemPath path = 1;


    pub fn get_path(&self) -> &ItemPath {
        self.path.as_ref().unwrap_or_else(|| <ItemPath as ::protobuf::Message>::default_instance())
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ItemPath) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ItemPath {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ItemPath {
        self.path.take().unwrap_or_else(|| ItemPath::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string short_description = 4;


    pub fn get_short_description(&self) -> &str {
        &self.short_description
    }
    pub fn clear_short_description(&mut self) {
        self.short_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_short_description(&mut self, v: ::std::string::String) {
        self.short_description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_short_description(&mut self) -> &mut ::std::string::String {
        &mut self.short_description
    }

    // Take field
    pub fn take_short_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.short_description, ::std::string::String::new())
    }

    // repeated .character.ItemType types = 5;


    pub fn get_types(&self) -> &[ItemType] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<ItemType>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<ItemType> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<ItemType> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }

    // double amount = 6;


    pub fn get_amount(&self) -> f64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: f64) {
        self.amount = v;
    }

    // double value = 8;


    pub fn get_value(&self) -> f64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = v;
    }

    // .character.ItemType sub_item_type = 7;


    pub fn get_sub_item_type(&self) -> ItemType {
        match self._sub_item_type {
            ::std::option::Option::Some(Item_oneof__sub_item_type::sub_item_type(v)) => v,
            _ => ItemType::armor,
        }
    }
    pub fn clear_sub_item_type(&mut self) {
        self._sub_item_type = ::std::option::Option::None;
    }

    pub fn has_sub_item_type(&self) -> bool {
        match self._sub_item_type {
            ::std::option::Option::Some(Item_oneof__sub_item_type::sub_item_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sub_item_type(&mut self, v: ItemType) {
        self._sub_item_type = ::std::option::Option::Some(Item_oneof__sub_item_type::sub_item_type(v))
    }

    // int32 armor = 9;


    pub fn get_armor(&self) -> i32 {
        match self._armor {
            ::std::option::Option::Some(Item_oneof__armor::armor(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_armor(&mut self) {
        self._armor = ::std::option::Option::None;
    }

    pub fn has_armor(&self) -> bool {
        match self._armor {
            ::std::option::Option::Some(Item_oneof__armor::armor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_armor(&mut self, v: i32) {
        self._armor = ::std::option::Option::Some(Item_oneof__armor::armor(v))
    }
}

impl ::protobuf::Message for Item {
    fn is_initialized(&self) -> bool {
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.short_description)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.types, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.amount = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._sub_item_type = ::std::option::Option::Some(Item_oneof__sub_item_type::sub_item_type(is.read_enum()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._armor = ::std::option::Option::Some(Item_oneof__armor::armor(is.read_int32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.short_description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.short_description);
        }
        for value in &self.types {
            my_size += ::protobuf::rt::enum_size(5, *value);
        };
        if self.amount != 0. {
            my_size += 9;
        }
        if self.value != 0. {
            my_size += 9;
        }
        if let ::std::option::Option::Some(ref v) = self._sub_item_type {
            match v {
                &Item_oneof__sub_item_type::sub_item_type(v) => {
                    my_size += ::protobuf::rt::enum_size(7, v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._armor {
            match v {
                &Item_oneof__armor::armor(v) => {
                    my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.short_description.is_empty() {
            os.write_string(4, &self.short_description)?;
        }
        for v in &self.types {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.amount != 0. {
            os.write_double(6, self.amount)?;
        }
        if self.value != 0. {
            os.write_double(8, self.value)?;
        }
        if let ::std::option::Option::Some(ref v) = self._sub_item_type {
            match v {
                &Item_oneof__sub_item_type::sub_item_type(v) => {
                    os.write_enum(7, ::protobuf::ProtobufEnum::value(&v))?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._armor {
            match v {
                &Item_oneof__armor::armor(v) => {
                    os.write_int32(9, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Item {
        Item::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ItemPath>>(
                "path",
                |m: &Item| { &m.path },
                |m: &mut Item| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Item| { &m.name },
                |m: &mut Item| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Item| { &m.description },
                |m: &mut Item| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "short_description",
                |m: &Item| { &m.short_description },
                |m: &mut Item| { &mut m.short_description },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ItemType>>(
                "types",
                |m: &Item| { &m.types },
                |m: &mut Item| { &mut m.types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "amount",
                |m: &Item| { &m.amount },
                |m: &mut Item| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "value",
                |m: &Item| { &m.value },
                |m: &mut Item| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, ItemType>(
                "sub_item_type",
                Item::has_sub_item_type,
                Item::get_sub_item_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "armor",
                Item::has_armor,
                Item::get_armor,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Item>(
                "Item",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Item {
        static instance: ::protobuf::rt::LazyV2<Item> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Item::new)
    }
}

impl ::protobuf::Clear for Item {
    fn clear(&mut self) {
        self.path.clear();
        self.name.clear();
        self.description.clear();
        self.short_description.clear();
        self.types.clear();
        self.amount = 0.;
        self.value = 0.;
        self._sub_item_type = ::std::option::Option::None;
        self._armor = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Item {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Note {
    // message fields
    pub uuid: ::std::string::String,
    pub title: ::std::string::String,
    pub field_type: NoteType,
    pub shortDescription: ::std::string::String,
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Note {
    fn default() -> &'a Note {
        <Note as ::protobuf::Message>::default_instance()
    }
}

impl Note {
    pub fn new() -> Note {
        ::std::default::Default::default()
    }

    // string uuid = 1;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // string title = 2;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // .character.NoteType type = 3;


    pub fn get_field_type(&self) -> NoteType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = NoteType::misc;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: NoteType) {
        self.field_type = v;
    }

    // string shortDescription = 4;


    pub fn get_shortDescription(&self) -> &str {
        &self.shortDescription
    }
    pub fn clear_shortDescription(&mut self) {
        self.shortDescription.clear();
    }

    // Param is passed by value, moved
    pub fn set_shortDescription(&mut self, v: ::std::string::String) {
        self.shortDescription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortDescription(&mut self) -> &mut ::std::string::String {
        &mut self.shortDescription
    }

    // Take field
    pub fn take_shortDescription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.shortDescription, ::std::string::String::new())
    }

    // string text = 5;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Note {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.shortDescription)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if self.field_type != NoteType::misc {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        if !self.shortDescription.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.shortDescription);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if self.field_type != NoteType::misc {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.shortDescription.is_empty() {
            os.write_string(4, &self.shortDescription)?;
        }
        if !self.text.is_empty() {
            os.write_string(5, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Note {
        Note::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &Note| { &m.uuid },
                |m: &mut Note| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Note| { &m.title },
                |m: &mut Note| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NoteType>>(
                "type",
                |m: &Note| { &m.field_type },
                |m: &mut Note| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shortDescription",
                |m: &Note| { &m.shortDescription },
                |m: &mut Note| { &mut m.shortDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &Note| { &m.text },
                |m: &mut Note| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Note>(
                "Note",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Note {
        static instance: ::protobuf::rt::LazyV2<Note> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Note::new)
    }
}

impl ::protobuf::Clear for Note {
    fn clear(&mut self) {
        self.uuid.clear();
        self.title.clear();
        self.field_type = NoteType::misc;
        self.shortDescription.clear();
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Note {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Note {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Advancement {
    increaseCapabilities = 0,
    moveTowardPerfection = 1,
    extraEffort = 2,
    skillTraining = 3,
    other = 4,
}

impl ::protobuf::ProtobufEnum for Advancement {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Advancement> {
        match value {
            0 => ::std::option::Option::Some(Advancement::increaseCapabilities),
            1 => ::std::option::Option::Some(Advancement::moveTowardPerfection),
            2 => ::std::option::Option::Some(Advancement::extraEffort),
            3 => ::std::option::Option::Some(Advancement::skillTraining),
            4 => ::std::option::Option::Some(Advancement::other),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Advancement] = &[
            Advancement::increaseCapabilities,
            Advancement::moveTowardPerfection,
            Advancement::extraEffort,
            Advancement::skillTraining,
            Advancement::other,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Advancement>("Advancement", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Advancement {
}

impl ::std::default::Default for Advancement {
    fn default() -> Self {
        Advancement::increaseCapabilities
    }
}

impl ::protobuf::reflect::ProtobufValue for Advancement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PoolType {
    intellect = 0,
    speed = 1,
    might = 2,
}

impl ::protobuf::ProtobufEnum for PoolType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PoolType> {
        match value {
            0 => ::std::option::Option::Some(PoolType::intellect),
            1 => ::std::option::Option::Some(PoolType::speed),
            2 => ::std::option::Option::Some(PoolType::might),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PoolType] = &[
            PoolType::intellect,
            PoolType::speed,
            PoolType::might,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PoolType>("PoolType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PoolType {
}

impl ::std::default::Default for PoolType {
    fn default() -> Self {
        PoolType::intellect
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Recover {
    one_action = 0,
    ten_minutes = 1,
    one_hour = 2,
    ten_hours = 3,
}

impl ::protobuf::ProtobufEnum for Recover {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Recover> {
        match value {
            0 => ::std::option::Option::Some(Recover::one_action),
            1 => ::std::option::Option::Some(Recover::ten_minutes),
            2 => ::std::option::Option::Some(Recover::one_hour),
            3 => ::std::option::Option::Some(Recover::ten_hours),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Recover] = &[
            Recover::one_action,
            Recover::ten_minutes,
            Recover::one_hour,
            Recover::ten_hours,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Recover>("Recover", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Recover {
}

impl ::std::default::Default for Recover {
    fn default() -> Self {
        Recover::one_action
    }
}

impl ::protobuf::reflect::ProtobufValue for Recover {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SkillLevel {
    specialized = 0,
    trained = 1,
    inability = 2,
}

impl ::protobuf::ProtobufEnum for SkillLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SkillLevel> {
        match value {
            0 => ::std::option::Option::Some(SkillLevel::specialized),
            1 => ::std::option::Option::Some(SkillLevel::trained),
            2 => ::std::option::Option::Some(SkillLevel::inability),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SkillLevel] = &[
            SkillLevel::specialized,
            SkillLevel::trained,
            SkillLevel::inability,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SkillLevel>("SkillLevel", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SkillLevel {
}

impl ::std::default::Default for SkillLevel {
    fn default() -> Self {
        SkillLevel::specialized
    }
}

impl ::protobuf::reflect::ProtobufValue for SkillLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CypherType {
    cypher = 0,
    artifact = 1,
}

impl ::protobuf::ProtobufEnum for CypherType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CypherType> {
        match value {
            0 => ::std::option::Option::Some(CypherType::cypher),
            1 => ::std::option::Option::Some(CypherType::artifact),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CypherType] = &[
            CypherType::cypher,
            CypherType::artifact,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CypherType>("CypherType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CypherType {
}

impl ::std::default::Default for CypherType {
    fn default() -> Self {
        CypherType::cypher
    }
}

impl ::protobuf::reflect::ProtobufValue for CypherType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ItemType {
    armor = 0,
    weapon = 10,
    clothing = 20,
    tool = 30,
    oddity = 40,
    material = 50,
    ammo = 60,
    plan = 70,
    others = 900,
}

impl ::protobuf::ProtobufEnum for ItemType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ItemType> {
        match value {
            0 => ::std::option::Option::Some(ItemType::armor),
            10 => ::std::option::Option::Some(ItemType::weapon),
            20 => ::std::option::Option::Some(ItemType::clothing),
            30 => ::std::option::Option::Some(ItemType::tool),
            40 => ::std::option::Option::Some(ItemType::oddity),
            50 => ::std::option::Option::Some(ItemType::material),
            60 => ::std::option::Option::Some(ItemType::ammo),
            70 => ::std::option::Option::Some(ItemType::plan),
            900 => ::std::option::Option::Some(ItemType::others),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ItemType] = &[
            ItemType::armor,
            ItemType::weapon,
            ItemType::clothing,
            ItemType::tool,
            ItemType::oddity,
            ItemType::material,
            ItemType::ammo,
            ItemType::plan,
            ItemType::others,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ItemType>("ItemType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ItemType {
}

impl ::std::default::Default for ItemType {
    fn default() -> Self {
        ItemType::armor
    }
}

impl ::protobuf::reflect::ProtobufValue for ItemType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NoteType {
    misc = 0,
    location = 1,
    character = 2,
    item = 3,
    quest = 4,
}

impl ::protobuf::ProtobufEnum for NoteType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NoteType> {
        match value {
            0 => ::std::option::Option::Some(NoteType::misc),
            1 => ::std::option::Option::Some(NoteType::location),
            2 => ::std::option::Option::Some(NoteType::character),
            3 => ::std::option::Option::Some(NoteType::item),
            4 => ::std::option::Option::Some(NoteType::quest),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NoteType] = &[
            NoteType::misc,
            NoteType::location,
            NoteType::character,
            NoteType::item,
            NoteType::quest,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NoteType>("NoteType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NoteType {
}

impl ::std::default::Default for NoteType {
    fn default() -> Self {
        NoteType::misc
    }
}

impl ::protobuf::reflect::ProtobufValue for NoteType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fcharacter.proto\x12\tcharacter\"\xea\x01\n\x11CharacterMetadata\
    \x12\x12\n\x04uuid\x18\x01\x20\x01(\tR\x04uuid\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x20\n\x0blastUpdated\x18\x05\x20\x01(\x03R\x0bl\
    astUpdated\x12\x1c\n\trevisions\x18\x03\x20\x03(\x05R\trevisions\x12!\n\
    \x0cstorage_size\x18\x04\x20\x01(\x05R\x0bstorageSize\x12'\n\x0flatest_r\
    evision\x18\x07\x20\x01(\x04R\x0elatestRevision\x12!\n\x0cstorage_uuid\
    \x18\x08\x20\x01(\tR\x0bstorageUuid\"\xde\x05\n\tCharacter\x12\x12\n\x04\
    uuid\x18\x01\x20\x01(\tR\x04uuid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x1e\n\ndescriptor\x18\x03\x20\x01(\tR\ndescriptor\x12\x12\n\
    \x04type\x18\x04\x20\x01(\tR\x04type\x12\x14\n\x05focus\x18\x05\x20\x01(\
    \tR\x05focus\x12/\n\x05color\x18\x11\x20\x01(\x0b2\x19.character.Charact\
    erColorR\x05color\x12/\n\x08progress\x18\x06\x20\x01(\x0b2\x13.character\
    .ProgressR\x08progress\x12&\n\x05stats\x18\x07\x20\x01(\x0b2\x10.charact\
    er.StatsR\x05stats\x12/\n\x08recovery\x18\x08\x20\x01(\x0b2\x13.characte\
    r.RecoveryR\x08recovery\x12)\n\x06damage\x18\t\x20\x01(\x0b2\x11.charact\
    er.DamageR\x06damage\x12(\n\x06skills\x18\n\x20\x03(\x0b2\x10.character.\
    SkillR\x06skills\x120\n\tabilities\x18\x0b\x20\x03(\x0b2\x12.character.A\
    bilityR\tabilities\x12!\n\x0ccypher_limit\x18\x0c\x20\x01(\x05R\x0bcyphe\
    rLimit\x12+\n\x07cyphers\x18\r\x20\x03(\x0b2\x11.character.CypherR\x07cy\
    phers\x121\n\tartifacts\x18\x0e\x20\x03(\x0b2\x13.character.ArtifactR\ta\
    rtifacts\x12\x14\n\x05money\x18\x0f\x20\x01(\x01R\x05money\x126\n\x0binv\
    entories\x18\x10\x20\x03(\x0b2\x14.character.InventoryR\x0binventories\
    \x12%\n\x05items\x18\x12\x20\x03(\x0b2\x0f.character.ItemR\x05items\x12%\
    \n\x05notes\x18\x13\x20\x03(\x0b2\x0f.character.NoteR\x05notes\":\n\x0eC\
    haracterColor\x12\x0c\n\x01r\x18\x01\x20\x01(\x05R\x01r\x12\x0c\n\x01g\
    \x18\x02\x20\x01(\x05R\x01g\x12\x0c\n\x01b\x18\x03\x20\x01(\x05R\x01b\"G\
    \n\x0fAdvancementInfo\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\"\xd4\x01\n\x0c\
    Advancements\x122\n\x14increaseCapabilities\x18\x01\x20\x01(\x08R\x14inc\
    reaseCapabilities\x122\n\x14moveTowardPerfection\x18\x02\x20\x01(\x08R\
    \x14moveTowardPerfection\x12\x20\n\x0bextraEffort\x18\x03\x20\x01(\x08R\
    \x0bextraEffort\x12$\n\rskillTraining\x18\x04\x20\x01(\x08R\rskillTraini\
    ng\x12\x14\n\x05other\x18\x05\x20\x01(\x08R\x05other\"\xae\x01\n\x08Prog\
    ress\x12\x12\n\x04tier\x18\x01\x20\x01(\x05R\x04tier\x12\x17\n\x07free_x\
    p\x18\x02\x20\x01(\x05R\x06freeXp\x12\x19\n\x08total_xp\x18\x03\x20\x01(\
    \x05R\x07totalXp\x12\x1d\n\nmax_effort\x18\x04\x20\x01(\x05R\tmaxEffort\
    \x12;\n\x0cadvancements\x18\x05\x20\x01(\x0b2\x17.character.Advancements\
    R\x0cadvancements\"i\n\x04Stat\x12'\n\x04type\x18\x01\x20\x01(\x0e2\x13.\
    character.PoolTypeR\x04type\x12\x10\n\x03cap\x18\x02\x20\x01(\x05R\x03ca\
    p\x12\x12\n\x04pool\x18\x03\x20\x01(\x05R\x04pool\x12\x12\n\x04edge\x18\
    \x04\x20\x01(\x05R\x04edge\"\x84\x01\n\x05Stats\x12-\n\tintellect\x18\
    \x01\x20\x01(\x0b2\x0f.character.StatR\tintellect\x12%\n\x05speed\x18\
    \x02\x20\x01(\x0b2\x0f.character.StatR\x05speed\x12%\n\x05might\x18\x03\
    \x20\x01(\x0b2\x0f.character.StatR\x05might\"\x98\x01\n\x08Recovery\x12\
    \x14\n\x05bonus\x18\x01\x20\x01(\x05R\x05bonus\x12\x1d\n\none_action\x18\
    \x02\x20\x01(\x08R\toneAction\x12\x1f\n\x0bten_minutes\x18\x03\x20\x01(\
    \x08R\ntenMinutes\x12\x19\n\x08one_hour\x18\x04\x20\x01(\x08R\x07oneHour\
    \x12\x1b\n\tten_hours\x18\x05\x20\x01(\x08R\x08tenHours\"F\n\x06Damage\
    \x12\x1a\n\x08impaired\x18\x01\x20\x01(\x08R\x08impaired\x12\x20\n\x0bde\
    bilitated\x18\x02\x20\x01(\x08R\x0bdebilitated\"\xa7\x01\n\x05Skill\x12\
    \x12\n\x04uuid\x18\x01\x20\x01(\tR\x04uuid\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescrip\
    tion\x12'\n\x04type\x18\x04\x20\x01(\x0e2\x13.character.PoolTypeR\x04typ\
    e\x12+\n\x05level\x18\x05\x20\x01(\x0e2\x15.character.SkillLevelR\x05lev\
    el\"\xd7\x01\n\x07Ability\x12\x12\n\x04uuid\x18\x01\x20\x01(\tR\x04uuid\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04cost\x18\x03\
    \x20\x01(\tR\x04cost\x12'\n\x04type\x18\x04\x20\x01(\x0e2\x13.character.\
    PoolTypeR\x04type\x12\x18\n\x07enabler\x18\x05\x20\x01(\x08R\x07enabler\
    \x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescription\x12+\n\x11s\
    hort_description\x18\x07\x20\x01(\tR\x10shortDescription\"\x91\x02\n\x06\
    Cypher\x12\x12\n\x04uuid\x18\x01\x20\x01(\tR\x04uuid\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12\x14\n\x05level\x18\x03\x20\x01(\tR\x05l\
    evel\x12+\n\x11short_description\x18\x04\x20\x01(\tR\x10shortDescription\
    \x12\x16\n\x06effect\x18\x05\x20\x01(\tR\x06effect\x12\x16\n\x06active\
    \x18\x06\x20\x01(\x08R\x06active\x12\x1c\n\tdepletion\x18\x07\x20\x01(\t\
    R\tdepletion\x12\x1a\n\x08internal\x18\x08\x20\x01(\tR\x08internal\x12\
    \x1a\n\x08wearable\x18\t\x20\x01(\tR\x08wearable\x12\x16\n\x06usable\x18\
    \n\x20\x01(\tR\x06usable\"\xd7\x01\n\x08Artifact\x12\x12\n\x04uuid\x18\
    \x01\x20\x01(\tR\x04uuid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \x12\x14\n\x05level\x18\x03\x20\x01(\tR\x05level\x12+\n\x11short_descrip\
    tion\x18\x04\x20\x01(\tR\x10shortDescription\x12\x16\n\x06effect\x18\x05\
    \x20\x01(\tR\x06effect\x12\x16\n\x06active\x18\x06\x20\x01(\x08R\x06acti\
    ve\x12\x1c\n\tdepletion\x18\x07\x20\x01(\tR\tdepletion\x12\x12\n\x04form\
    \x18\x08\x20\x01(\tR\x04form\"I\n\tInventory\x12\x12\n\x04uuid\x18\x01\
    \x20\x01(\tR\x04uuid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x14\n\x05order\x18\x04\x20\x01(\x05R\x05order\"T\n\x08ItemPath\x12\x1c\
    \n\tinventory\x18\x01\x20\x01(\tR\tinventory\x12\x16\n\x06parent\x18\x02\
    \x20\x01(\tR\x06parent\x12\x12\n\x04self\x18\x03\x20\x01(\tR\x04self\"\
    \xe0\x02\n\x04Item\x12'\n\x04path\x18\x01\x20\x01(\x0b2\x13.character.It\
    emPathR\x04path\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\
    \x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12+\n\x11short_descr\
    iption\x18\x04\x20\x01(\tR\x10shortDescription\x12)\n\x05types\x18\x05\
    \x20\x03(\x0e2\x13.character.ItemTypeR\x05types\x12\x16\n\x06amount\x18\
    \x06\x20\x01(\x01R\x06amount\x12\x14\n\x05value\x18\x08\x20\x01(\x01R\
    \x05value\x12<\n\rsub_item_type\x18\x07\x20\x01(\x0e2\x13.character.Item\
    TypeH\0R\x0bsubItemType\x88\x01\x01\x12\x19\n\x05armor\x18\t\x20\x01(\
    \x05H\x01R\x05armor\x88\x01\x01B\x10\n\x0e_sub_item_typeB\x08\n\x06_armo\
    r\"\x99\x01\n\x04Note\x12\x12\n\x04uuid\x18\x01\x20\x01(\tR\x04uuid\x12\
    \x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12'\n\x04type\x18\x03\x20\
    \x01(\x0e2\x13.character.NoteTypeR\x04type\x12*\n\x10shortDescription\
    \x18\x04\x20\x01(\tR\x10shortDescription\x12\x12\n\x04text\x18\x05\x20\
    \x01(\tR\x04text*p\n\x0bAdvancement\x12\x18\n\x14increaseCapabilities\
    \x10\0\x12\x18\n\x14moveTowardPerfection\x10\x01\x12\x0f\n\x0bextraEffor\
    t\x10\x02\x12\x11\n\rskillTraining\x10\x03\x12\t\n\x05other\x10\x04*/\n\
    \x08PoolType\x12\r\n\tintellect\x10\0\x12\t\n\x05speed\x10\x01\x12\t\n\
    \x05might\x10\x02*G\n\x07Recover\x12\x0e\n\none_action\x10\0\x12\x0f\n\
    \x0bten_minutes\x10\x01\x12\x0c\n\x08one_hour\x10\x02\x12\r\n\tten_hours\
    \x10\x03*9\n\nSkillLevel\x12\x0f\n\x0bspecialized\x10\0\x12\x0b\n\x07tra\
    ined\x10\x01\x12\r\n\tinability\x10\x02*&\n\nCypherType\x12\n\n\x06cyphe\
    r\x10\0\x12\x0c\n\x08artifact\x10\x01*t\n\x08ItemType\x12\t\n\x05armor\
    \x10\0\x12\n\n\x06weapon\x10\n\x12\x0c\n\x08clothing\x10\x14\x12\x08\n\
    \x04tool\x10\x1e\x12\n\n\x06oddity\x10(\x12\x0c\n\x08material\x102\x12\
    \x08\n\x04ammo\x10<\x12\x08\n\x04plan\x10F\x12\x0b\n\x06others\x10\x84\
    \x07*F\n\x08NoteType\x12\x08\n\x04misc\x10\0\x12\x0c\n\x08location\x10\
    \x01\x12\r\n\tcharacter\x10\x02\x12\x08\n\x04item\x10\x03\x12\t\n\x05que\
    st\x10\x04J\x9dB\n\x07\x12\x05\0\0\xeb\x01\x01\n\x08\n\x01\x0c\x12\x03\0\
    \0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x12\n\n\n\x02\x04\0\x12\x04\x04\0\
    \x15\x01\n\n\n\x03\x04\0\x01\x12\x03\x04\x08\x19\n\x0b\n\x04\x04\0\x02\0\
    \x12\x03\x05\x02\x12\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x05\x02\x08\n\
    \x0c\n\x05\x04\0\x02\0\x01\x12\x03\x05\t\r\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03\x05\x10\x11\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x06\x02\x12\n\x0c\
    \n\x05\x04\0\x02\x01\x05\x12\x03\x06\x02\x08\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03\x06\t\r\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x06\x10\x11\n\
    \x0b\n\x04\x04\0\x02\x02\x12\x03\x07\x02\x18\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x03\x07\x02\x07\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x07\x08\
    \x13\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x07\x16\x17\nm\n\x04\x04\0\
    \x02\x03\x12\x03\x0b\x02\x1f\x1a`\x20The\x20below\x20fields\x20are\x20no\
    t\x20persisted\x20as\x20part\x20of\x20the\x20metadata\x20file\n\x20but\
    \x20only\x20generated\x20at\x20runtime\n\n\x0c\n\x05\x04\0\x02\x03\x04\
    \x12\x03\x0b\x02\n\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x0b\x0b\x10\n\
    \x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x0b\x11\x1a\n\x0c\n\x05\x04\0\x02\
    \x03\x03\x12\x03\x0b\x1d\x1e\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x0c\x02\
    \x19\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x0c\x02\x07\n\x0c\n\x05\x04\0\
    \x02\x04\x01\x12\x03\x0c\x08\x14\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\
    \x0c\x17\x18\nz\n\x04\x04\0\x02\x05\x12\x03\x10\x02\x1d\x1am\x20latest\
    \x20revision\x20may\x20be\x20outdated\x20when\x20read\x20from\x20storage\
    \x20and\x20should\x20be\n\x20checked/refreshed\x20on\x20initial\x20index\
    ing\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03\x10\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x05\x01\x12\x03\x10\t\x18\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\
    \x10\x1b\x1c\n\x99\x01\n\x04\x04\0\x02\x06\x12\x03\x14\x02\x1a\x1a\x8b\
    \x01\x20storage_uuid\x20is\x20assigned\x20to\x20the\x20character\x20by\
    \x20the\x20database\n\x20right\x20now\x20this\x20is\x20mainly\x20used\
    \x20to\x20avoid\x20file\x20system\x20access\x20based\x20on\x20user\n\x20\
    input\n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x06\x01\x12\x03\x14\t\x15\n\x0c\n\x05\x04\0\x02\x06\x03\x12\
    \x03\x14\x18\x19\n\n\n\x02\x04\x01\x12\x04\x17\01\x01\n\n\n\x03\x04\x01\
    \x01\x12\x03\x17\x08\x11\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x18\x02\x12\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x18\x02\x08\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03\x18\t\r\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x18\x10\x11\
    \n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x1a\x02\x12\n\x0c\n\x05\x04\x01\x02\
    \x01\x05\x12\x03\x1a\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x1a\
    \t\r\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1a\x10\x11\n\x0b\n\x04\x04\
    \x01\x02\x02\x12\x03\x1b\x02\x18\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\
    \x1b\x02\x08\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\x1b\t\x13\n\x0c\n\
    \x05\x04\x01\x02\x02\x03\x12\x03\x1b\x16\x17\n\x0b\n\x04\x04\x01\x02\x03\
    \x12\x03\x1c\x02\x12\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\x1c\x02\x08\
    \n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\x1c\t\r\n\x0c\n\x05\x04\x01\x02\
    \x03\x03\x12\x03\x1c\x10\x11\n\x0b\n\x04\x04\x01\x02\x04\x12\x03\x1d\x02\
    \x13\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03\x1d\x02\x08\n\x0c\n\x05\x04\
    \x01\x02\x04\x01\x12\x03\x1d\t\x0e\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\
    \x03\x1d\x11\x12\n\x0b\n\x04\x04\x01\x02\x05\x12\x03\x1e\x02\x1c\n\x0c\n\
    \x05\x04\x01\x02\x05\x06\x12\x03\x1e\x02\x10\n\x0c\n\x05\x04\x01\x02\x05\
    \x01\x12\x03\x1e\x11\x16\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03\x1e\x19\
    \x1b\n\x0b\n\x04\x04\x01\x02\x06\x12\x03\x20\x02\x18\n\x0c\n\x05\x04\x01\
    \x02\x06\x06\x12\x03\x20\x02\n\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03\
    \x20\x0b\x13\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03\x20\x16\x17\n\x0b\n\
    \x04\x04\x01\x02\x07\x12\x03!\x02\x12\n\x0c\n\x05\x04\x01\x02\x07\x06\
    \x12\x03!\x02\x07\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03!\x08\r\n\x0c\n\
    \x05\x04\x01\x02\x07\x03\x12\x03!\x10\x11\n\x0b\n\x04\x04\x01\x02\x08\
    \x12\x03\"\x02\x18\n\x0c\n\x05\x04\x01\x02\x08\x06\x12\x03\"\x02\n\n\x0c\
    \n\x05\x04\x01\x02\x08\x01\x12\x03\"\x0b\x13\n\x0c\n\x05\x04\x01\x02\x08\
    \x03\x12\x03\"\x16\x17\n\x0b\n\x04\x04\x01\x02\t\x12\x03#\x02\x14\n\x0c\
    \n\x05\x04\x01\x02\t\x06\x12\x03#\x02\x08\n\x0c\n\x05\x04\x01\x02\t\x01\
    \x12\x03#\t\x0f\n\x0c\n\x05\x04\x01\x02\t\x03\x12\x03#\x12\x13\n\x0b\n\
    \x04\x04\x01\x02\n\x12\x03%\x02\x1d\n\x0c\n\x05\x04\x01\x02\n\x04\x12\
    \x03%\x02\n\n\x0c\n\x05\x04\x01\x02\n\x06\x12\x03%\x0b\x10\n\x0c\n\x05\
    \x04\x01\x02\n\x01\x12\x03%\x11\x17\n\x0c\n\x05\x04\x01\x02\n\x03\x12\
    \x03%\x1a\x1c\n\x0b\n\x04\x04\x01\x02\x0b\x12\x03&\x02\"\n\x0c\n\x05\x04\
    \x01\x02\x0b\x04\x12\x03&\x02\n\n\x0c\n\x05\x04\x01\x02\x0b\x06\x12\x03&\
    \x0b\x12\n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x03&\x13\x1c\n\x0c\n\x05\
    \x04\x01\x02\x0b\x03\x12\x03&\x1f!\n\x0b\n\x04\x04\x01\x02\x0c\x12\x03(\
    \x02\x1a\n\x0c\n\x05\x04\x01\x02\x0c\x05\x12\x03(\x02\x07\n\x0c\n\x05\
    \x04\x01\x02\x0c\x01\x12\x03(\x08\x14\n\x0c\n\x05\x04\x01\x02\x0c\x03\
    \x12\x03(\x17\x19\n\x0b\n\x04\x04\x01\x02\r\x12\x03)\x02\x1f\n\x0c\n\x05\
    \x04\x01\x02\r\x04\x12\x03)\x02\n\n\x0c\n\x05\x04\x01\x02\r\x06\x12\x03)\
    \x0b\x11\n\x0c\n\x05\x04\x01\x02\r\x01\x12\x03)\x12\x19\n\x0c\n\x05\x04\
    \x01\x02\r\x03\x12\x03)\x1c\x1e\n\x0b\n\x04\x04\x01\x02\x0e\x12\x03*\x02\
    #\n\x0c\n\x05\x04\x01\x02\x0e\x04\x12\x03*\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x0e\x06\x12\x03*\x0b\x13\n\x0c\n\x05\x04\x01\x02\x0e\x01\x12\x03*\x14\
    \x1d\n\x0c\n\x05\x04\x01\x02\x0e\x03\x12\x03*\x20\"\n\x0b\n\x04\x04\x01\
    \x02\x0f\x12\x03,\x02\x14\n\x0c\n\x05\x04\x01\x02\x0f\x05\x12\x03,\x02\
    \x08\n\x0c\n\x05\x04\x01\x02\x0f\x01\x12\x03,\t\x0e\n\x0c\n\x05\x04\x01\
    \x02\x0f\x03\x12\x03,\x11\x13\n\x0b\n\x04\x04\x01\x02\x10\x12\x03-\x02&\
    \n\x0c\n\x05\x04\x01\x02\x10\x04\x12\x03-\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x10\x06\x12\x03-\x0b\x14\n\x0c\n\x05\x04\x01\x02\x10\x01\x12\x03-\x15\
    \x20\n\x0c\n\x05\x04\x01\x02\x10\x03\x12\x03-#%\n\x0b\n\x04\x04\x01\x02\
    \x11\x12\x03.\x02\x1b\n\x0c\n\x05\x04\x01\x02\x11\x04\x12\x03.\x02\n\n\
    \x0c\n\x05\x04\x01\x02\x11\x06\x12\x03.\x0b\x0f\n\x0c\n\x05\x04\x01\x02\
    \x11\x01\x12\x03.\x10\x15\n\x0c\n\x05\x04\x01\x02\x11\x03\x12\x03.\x18\
    \x1a\n\x0b\n\x04\x04\x01\x02\x12\x12\x030\x02\x1b\n\x0c\n\x05\x04\x01\
    \x02\x12\x04\x12\x030\x02\n\n\x0c\n\x05\x04\x01\x02\x12\x06\x12\x030\x0b\
    \x0f\n\x0c\n\x05\x04\x01\x02\x12\x01\x12\x030\x10\x15\n\x0c\n\x05\x04\
    \x01\x02\x12\x03\x12\x030\x18\x1a\n\n\n\x02\x04\x02\x12\x043\07\x01\n\n\
    \n\x03\x04\x02\x01\x12\x033\x08\x16\n\x0b\n\x04\x04\x02\x02\0\x12\x034\
    \x02\x0e\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x034\x02\x07\n\x0c\n\x05\x04\
    \x02\x02\0\x01\x12\x034\x08\t\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x034\x0c\
    \r\n\x0b\n\x04\x04\x02\x02\x01\x12\x035\x02\x0e\n\x0c\n\x05\x04\x02\x02\
    \x01\x05\x12\x035\x02\x07\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x035\x08\t\
    \n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x035\x0c\r\n\x0b\n\x04\x04\x02\x02\
    \x02\x12\x036\x02\x0e\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x036\x02\x07\n\
    \x0c\n\x05\x04\x02\x02\x02\x01\x12\x036\x08\t\n\x0c\n\x05\x04\x02\x02\
    \x02\x03\x12\x036\x0c\r\n\n\n\x02\x05\0\x12\x049\0?\x01\n\n\n\x03\x05\0\
    \x01\x12\x039\x05\x10\n\x0b\n\x04\x05\0\x02\0\x12\x03:\x02\x1b\n\x0c\n\
    \x05\x05\0\x02\0\x01\x12\x03:\x02\x16\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03:\x19\x1a\n\x0b\n\x04\x05\0\x02\x01\x12\x03;\x02\x1b\n\x0c\n\x05\x05\
    \0\x02\x01\x01\x12\x03;\x02\x16\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03;\
    \x19\x1a\n\x0b\n\x04\x05\0\x02\x02\x12\x03<\x02\x12\n\x0c\n\x05\x05\0\
    \x02\x02\x01\x12\x03<\x02\r\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03<\x10\
    \x11\n\x0b\n\x04\x05\0\x02\x03\x12\x03=\x02\x14\n\x0c\n\x05\x05\0\x02\
    \x03\x01\x12\x03=\x02\x0f\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03=\x12\x13\
    \n\x0b\n\x04\x05\0\x02\x04\x12\x03>\x02\x0c\n\x0c\n\x05\x05\0\x02\x04\
    \x01\x12\x03>\x02\x07\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03>\n\x0b\n\n\n\
    \x02\x04\x03\x12\x04A\0D\x01\n\n\n\x03\x04\x03\x01\x12\x03A\x08\x17\n\
    \x0b\n\x04\x04\x03\x02\0\x12\x03B\x02\x12\n\x0c\n\x05\x04\x03\x02\0\x05\
    \x12\x03B\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03B\t\r\n\x0c\n\x05\
    \x04\x03\x02\0\x03\x12\x03B\x10\x11\n\x0b\n\x04\x04\x03\x02\x01\x12\x03C\
    \x02\x19\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03C\x02\x08\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x03C\t\x14\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\
    \x03C\x17\x18\n\n\n\x02\x04\x04\x12\x04F\0L\x01\n\n\n\x03\x04\x04\x01\
    \x12\x03F\x08\x14\n\x0b\n\x04\x04\x04\x02\0\x12\x03G\x02\x20\n\x0c\n\x05\
    \x04\x04\x02\0\x05\x12\x03G\x02\x06\n\x0c\n\x05\x04\x04\x02\0\x01\x12\
    \x03G\x07\x1b\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03G\x1e\x1f\n\x0b\n\x04\
    \x04\x04\x02\x01\x12\x03H\x02\x20\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\
    \x03H\x02\x06\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03H\x07\x1b\n\x0c\n\
    \x05\x04\x04\x02\x01\x03\x12\x03H\x1e\x1f\n\x0b\n\x04\x04\x04\x02\x02\
    \x12\x03I\x02\x17\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03I\x02\x06\n\x0c\
    \n\x05\x04\x04\x02\x02\x01\x12\x03I\x07\x12\n\x0c\n\x05\x04\x04\x02\x02\
    \x03\x12\x03I\x15\x16\n\x0b\n\x04\x04\x04\x02\x03\x12\x03J\x02\x19\n\x0c\
    \n\x05\x04\x04\x02\x03\x05\x12\x03J\x02\x06\n\x0c\n\x05\x04\x04\x02\x03\
    \x01\x12\x03J\x07\x14\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03J\x17\x18\n\
    \x0b\n\x04\x04\x04\x02\x04\x12\x03K\x02\x11\n\x0c\n\x05\x04\x04\x02\x04\
    \x05\x12\x03K\x02\x06\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03K\x07\x0c\n\
    \x0c\n\x05\x04\x04\x02\x04\x03\x12\x03K\x0f\x10\n\n\n\x02\x04\x05\x12\
    \x04N\0V\x01\n\n\n\x03\x04\x05\x01\x12\x03N\x08\x10\n\x0b\n\x04\x04\x05\
    \x02\0\x12\x03O\x02\x11\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03O\x02\x07\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03O\x08\x0c\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03O\x0f\x10\n\x0b\n\x04\x04\x05\x02\x01\x12\x03P\x02\x14\n\x0c\
    \n\x05\x04\x05\x02\x01\x05\x12\x03P\x02\x07\n\x0c\n\x05\x04\x05\x02\x01\
    \x01\x12\x03P\x08\x0f\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03P\x12\x13\n\
    \x0b\n\x04\x04\x05\x02\x02\x12\x03Q\x02\x15\n\x0c\n\x05\x04\x05\x02\x02\
    \x05\x12\x03Q\x02\x07\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03Q\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x03Q\x13\x14\n\x0b\n\x04\x04\x05\x02\
    \x03\x12\x03S\x02\x17\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03S\x02\x07\n\
    \x0c\n\x05\x04\x05\x02\x03\x01\x12\x03S\x08\x12\n\x0c\n\x05\x04\x05\x02\
    \x03\x03\x12\x03S\x15\x16\n\x0b\n\x04\x04\x05\x02\x04\x12\x03U\x02\x20\n\
    \x0c\n\x05\x04\x05\x02\x04\x06\x12\x03U\x02\x0e\n\x0c\n\x05\x04\x05\x02\
    \x04\x01\x12\x03U\x0f\x1b\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03U\x1e\
    \x1f\n\n\n\x02\x05\x01\x12\x04X\0\\\x01\n\n\n\x03\x05\x01\x01\x12\x03X\
    \x05\r\n\x0b\n\x04\x05\x01\x02\0\x12\x03Y\x02\x10\n\x0c\n\x05\x05\x01\
    \x02\0\x01\x12\x03Y\x02\x0b\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03Y\x0e\
    \x0f\n\x0b\n\x04\x05\x01\x02\x01\x12\x03Z\x02\x0c\n\x0c\n\x05\x05\x01\
    \x02\x01\x01\x12\x03Z\x02\x07\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03Z\n\
    \x0b\n\x0b\n\x04\x05\x01\x02\x02\x12\x03[\x02\x0c\n\x0c\n\x05\x05\x01\
    \x02\x02\x01\x12\x03[\x02\x07\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03[\n\
    \x0b\n\n\n\x02\x04\x06\x12\x04^\0c\x01\n\n\n\x03\x04\x06\x01\x12\x03^\
    \x08\x0c\n\x0b\n\x04\x04\x06\x02\0\x12\x03_\x02\x14\n\x0c\n\x05\x04\x06\
    \x02\0\x06\x12\x03_\x02\n\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03_\x0b\x0f\
    \n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03_\x12\x13\n\x0b\n\x04\x04\x06\x02\
    \x01\x12\x03`\x02\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03`\x02\x07\n\
    \x0c\n\x05\x04\x06\x02\x01\x01\x12\x03`\x08\x0b\n\x0c\n\x05\x04\x06\x02\
    \x01\x03\x12\x03`\x0e\x0f\n\x0b\n\x04\x04\x06\x02\x02\x12\x03a\x02\x11\n\
    \x0c\n\x05\x04\x06\x02\x02\x05\x12\x03a\x02\x07\n\x0c\n\x05\x04\x06\x02\
    \x02\x01\x12\x03a\x08\x0c\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03a\x0f\
    \x10\n\x0b\n\x04\x04\x06\x02\x03\x12\x03b\x02\x11\n\x0c\n\x05\x04\x06\
    \x02\x03\x05\x12\x03b\x02\x07\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03b\
    \x08\x0c\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03b\x0f\x10\n\n\n\x02\x04\
    \x07\x12\x04e\0i\x01\n\n\n\x03\x04\x07\x01\x12\x03e\x08\r\n\x0b\n\x04\
    \x04\x07\x02\0\x12\x03f\x02\x15\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03f\
    \x02\x06\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03f\x07\x10\n\x0c\n\x05\x04\
    \x07\x02\0\x03\x12\x03f\x13\x14\n\x0b\n\x04\x04\x07\x02\x01\x12\x03g\x02\
    \x11\n\x0c\n\x05\x04\x07\x02\x01\x06\x12\x03g\x02\x06\n\x0c\n\x05\x04\
    \x07\x02\x01\x01\x12\x03g\x07\x0c\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\
    \x03g\x0f\x10\n\x0b\n\x04\x04\x07\x02\x02\x12\x03h\x02\x11\n\x0c\n\x05\
    \x04\x07\x02\x02\x06\x12\x03h\x02\x06\n\x0c\n\x05\x04\x07\x02\x02\x01\
    \x12\x03h\x07\x0c\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03h\x0f\x10\n\n\n\
    \x02\x05\x02\x12\x04k\0p\x01\n\n\n\x03\x05\x02\x01\x12\x03k\x05\x0c\n\
    \x0b\n\x04\x05\x02\x02\0\x12\x03l\x02\x11\n\x0c\n\x05\x05\x02\x02\0\x01\
    \x12\x03l\x02\x0c\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03l\x0f\x10\n\x0b\n\
    \x04\x05\x02\x02\x01\x12\x03m\x02\x12\n\x0c\n\x05\x05\x02\x02\x01\x01\
    \x12\x03m\x02\r\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03m\x10\x11\n\x0b\n\
    \x04\x05\x02\x02\x02\x12\x03n\x02\x0f\n\x0c\n\x05\x05\x02\x02\x02\x01\
    \x12\x03n\x02\n\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03n\r\x0e\n\x0b\n\
    \x04\x05\x02\x02\x03\x12\x03o\x02\x10\n\x0c\n\x05\x05\x02\x02\x03\x01\
    \x12\x03o\x02\x0b\n\x0c\n\x05\x05\x02\x02\x03\x02\x12\x03o\x0e\x0f\n\n\n\
    \x02\x04\x08\x12\x04r\0y\x01\n\n\n\x03\x04\x08\x01\x12\x03r\x08\x10\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x03s\x02\x12\n\x0c\n\x05\x04\x08\x02\0\x05\
    \x12\x03s\x02\x07\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03s\x08\r\n\x0c\n\
    \x05\x04\x08\x02\0\x03\x12\x03s\x10\x11\n\x0b\n\x04\x04\x08\x02\x01\x12\
    \x03u\x02\x16\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03u\x02\x06\n\x0c\n\
    \x05\x04\x08\x02\x01\x01\x12\x03u\x07\x11\n\x0c\n\x05\x04\x08\x02\x01\
    \x03\x12\x03u\x14\x15\n\x0b\n\x04\x04\x08\x02\x02\x12\x03v\x02\x17\n\x0c\
    \n\x05\x04\x08\x02\x02\x05\x12\x03v\x02\x06\n\x0c\n\x05\x04\x08\x02\x02\
    \x01\x12\x03v\x07\x12\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03v\x15\x16\n\
    \x0b\n\x04\x04\x08\x02\x03\x12\x03w\x02\x14\n\x0c\n\x05\x04\x08\x02\x03\
    \x05\x12\x03w\x02\x06\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03w\x07\x0f\n\
    \x0c\n\x05\x04\x08\x02\x03\x03\x12\x03w\x12\x13\n\x0b\n\x04\x04\x08\x02\
    \x04\x12\x03x\x02\x15\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\x03x\x02\x06\n\
    \x0c\n\x05\x04\x08\x02\x04\x01\x12\x03x\x07\x10\n\x0c\n\x05\x04\x08\x02\
    \x04\x03\x12\x03x\x13\x14\n\n\n\x02\x04\t\x12\x04{\0~\x01\n\n\n\x03\x04\
    \t\x01\x12\x03{\x08\x0e\n\x0b\n\x04\x04\t\x02\0\x12\x03|\x02\x14\n\x0c\n\
    \x05\x04\t\x02\0\x05\x12\x03|\x02\x06\n\x0c\n\x05\x04\t\x02\0\x01\x12\
    \x03|\x07\x0f\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03|\x12\x13\n\x0b\n\x04\
    \x04\t\x02\x01\x12\x03}\x02\x17\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03}\
    \x02\x06\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03}\x07\x12\n\x0c\n\x05\x04\
    \t\x02\x01\x03\x12\x03}\x15\x16\n\x0c\n\x02\x05\x03\x12\x06\x80\x01\0\
    \x84\x01\x01\n\x0b\n\x03\x05\x03\x01\x12\x04\x80\x01\x05\x0f\n\x0c\n\x04\
    \x05\x03\x02\0\x12\x04\x81\x01\x02\x12\n\r\n\x05\x05\x03\x02\0\x01\x12\
    \x04\x81\x01\x02\r\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\x81\x01\x10\x11\n\
    \x0c\n\x04\x05\x03\x02\x01\x12\x04\x82\x01\x02\x0e\n\r\n\x05\x05\x03\x02\
    \x01\x01\x12\x04\x82\x01\x02\t\n\r\n\x05\x05\x03\x02\x01\x02\x12\x04\x82\
    \x01\x0c\r\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\x83\x01\x02\x10\n\r\n\x05\
    \x05\x03\x02\x02\x01\x12\x04\x83\x01\x02\x0b\n\r\n\x05\x05\x03\x02\x02\
    \x02\x12\x04\x83\x01\x0e\x0f\n\x0c\n\x02\x04\n\x12\x06\x86\x01\0\x8c\x01\
    \x01\n\x0b\n\x03\x04\n\x01\x12\x04\x86\x01\x08\r\n\x0c\n\x04\x04\n\x02\0\
    \x12\x04\x87\x01\x02\x12\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x87\x01\x02\
    \x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x87\x01\t\r\n\r\n\x05\x04\n\x02\0\
    \x03\x12\x04\x87\x01\x10\x11\n\x0c\n\x04\x04\n\x02\x01\x12\x04\x88\x01\
    \x02\x12\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x88\x01\x02\x08\n\r\n\x05\
    \x04\n\x02\x01\x01\x12\x04\x88\x01\t\r\n\r\n\x05\x04\n\x02\x01\x03\x12\
    \x04\x88\x01\x10\x11\n\x0c\n\x04\x04\n\x02\x02\x12\x04\x89\x01\x02\x19\n\
    \r\n\x05\x04\n\x02\x02\x05\x12\x04\x89\x01\x02\x08\n\r\n\x05\x04\n\x02\
    \x02\x01\x12\x04\x89\x01\t\x14\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x89\
    \x01\x17\x18\n\x0c\n\x04\x04\n\x02\x03\x12\x04\x8a\x01\x02\x14\n\r\n\x05\
    \x04\n\x02\x03\x06\x12\x04\x8a\x01\x02\n\n\r\n\x05\x04\n\x02\x03\x01\x12\
    \x04\x8a\x01\x0b\x0f\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\x8a\x01\x12\x13\
    \n\x0c\n\x04\x04\n\x02\x04\x12\x04\x8b\x01\x02\x17\n\r\n\x05\x04\n\x02\
    \x04\x06\x12\x04\x8b\x01\x02\x0c\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\x8b\
    \x01\r\x12\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\x8b\x01\x15\x16\n\x0c\n\
    \x02\x04\x0b\x12\x06\x8e\x01\0\x96\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\x8e\x01\x08\x0f\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x8f\x01\x02\x12\n\
    \r\n\x05\x04\x0b\x02\0\x05\x12\x04\x8f\x01\x02\x08\n\r\n\x05\x04\x0b\x02\
    \0\x01\x12\x04\x8f\x01\t\r\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x8f\x01\
    \x10\x11\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x90\x01\x02\x12\n\r\n\x05\
    \x04\x0b\x02\x01\x05\x12\x04\x90\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x01\
    \x01\x12\x04\x90\x01\t\r\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x90\x01\
    \x10\x11\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\x91\x01\x02\x12\n\r\n\x05\
    \x04\x0b\x02\x02\x05\x12\x04\x91\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x02\
    \x01\x12\x04\x91\x01\t\r\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x91\x01\
    \x10\x11\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\x92\x01\x02\x14\n\r\n\x05\
    \x04\x0b\x02\x03\x06\x12\x04\x92\x01\x02\n\n\r\n\x05\x04\x0b\x02\x03\x01\
    \x12\x04\x92\x01\x0b\x0f\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x92\x01\
    \x12\x13\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\x93\x01\x02\x13\n\r\n\x05\
    \x04\x0b\x02\x04\x05\x12\x04\x93\x01\x02\x06\n\r\n\x05\x04\x0b\x02\x04\
    \x01\x12\x04\x93\x01\x07\x0e\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x93\
    \x01\x11\x12\n\x0c\n\x04\x04\x0b\x02\x05\x12\x04\x94\x01\x02\x19\n\r\n\
    \x05\x04\x0b\x02\x05\x05\x12\x04\x94\x01\x02\x08\n\r\n\x05\x04\x0b\x02\
    \x05\x01\x12\x04\x94\x01\t\x14\n\r\n\x05\x04\x0b\x02\x05\x03\x12\x04\x94\
    \x01\x17\x18\n\x0c\n\x04\x04\x0b\x02\x06\x12\x04\x95\x01\x02\x1f\n\r\n\
    \x05\x04\x0b\x02\x06\x05\x12\x04\x95\x01\x02\x08\n\r\n\x05\x04\x0b\x02\
    \x06\x01\x12\x04\x95\x01\t\x1a\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\x95\
    \x01\x1d\x1e\n\x0c\n\x02\x05\x04\x12\x06\x98\x01\0\x9b\x01\x01\n\x0b\n\
    \x03\x05\x04\x01\x12\x04\x98\x01\x05\x0f\n\x0c\n\x04\x05\x04\x02\0\x12\
    \x04\x99\x01\x02\r\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\x99\x01\x02\x08\n\
    \r\n\x05\x05\x04\x02\0\x02\x12\x04\x99\x01\x0b\x0c\n\x0c\n\x04\x05\x04\
    \x02\x01\x12\x04\x9a\x01\x02\x0f\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\
    \x9a\x01\x02\n\n\r\n\x05\x05\x04\x02\x01\x02\x12\x04\x9a\x01\r\x0e\n\x0c\
    \n\x02\x04\x0c\x12\x06\x9d\x01\0\xa9\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\
    \x04\x9d\x01\x08\x0e\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x9e\x01\x02\x12\n\
    \r\n\x05\x04\x0c\x02\0\x05\x12\x04\x9e\x01\x02\x08\n\r\n\x05\x04\x0c\x02\
    \0\x01\x12\x04\x9e\x01\t\r\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x9e\x01\
    \x10\x11\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x9f\x01\x02\x12\n\r\n\x05\
    \x04\x0c\x02\x01\x05\x12\x04\x9f\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x01\
    \x01\x12\x04\x9f\x01\t\r\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\x9f\x01\
    \x10\x11\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xa0\x01\x02\x13\n\r\n\x05\
    \x04\x0c\x02\x02\x05\x12\x04\xa0\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x02\
    \x01\x12\x04\xa0\x01\t\x0e\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xa0\x01\
    \x11\x12\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\xa1\x01\x02\x1f\n\r\n\x05\
    \x04\x0c\x02\x03\x05\x12\x04\xa1\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x03\
    \x01\x12\x04\xa1\x01\t\x1a\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xa1\x01\
    \x1d\x1e\n\x0c\n\x04\x04\x0c\x02\x04\x12\x04\xa2\x01\x02\x14\n\r\n\x05\
    \x04\x0c\x02\x04\x05\x12\x04\xa2\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x04\
    \x01\x12\x04\xa2\x01\t\x0f\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xa2\x01\
    \x12\x13\n\x0c\n\x04\x04\x0c\x02\x05\x12\x04\xa3\x01\x02\x12\n\r\n\x05\
    \x04\x0c\x02\x05\x05\x12\x04\xa3\x01\x02\x06\n\r\n\x05\x04\x0c\x02\x05\
    \x01\x12\x04\xa3\x01\x07\r\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xa3\x01\
    \x10\x11\n\x0c\n\x04\x04\x0c\x02\x06\x12\x04\xa4\x01\x02\x17\n\r\n\x05\
    \x04\x0c\x02\x06\x05\x12\x04\xa4\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x06\
    \x01\x12\x04\xa4\x01\t\x12\n\r\n\x05\x04\x0c\x02\x06\x03\x12\x04\xa4\x01\
    \x15\x16\n\x0c\n\x04\x04\x0c\x02\x07\x12\x04\xa6\x01\x02\x16\n\r\n\x05\
    \x04\x0c\x02\x07\x05\x12\x04\xa6\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x07\
    \x01\x12\x04\xa6\x01\t\x11\n\r\n\x05\x04\x0c\x02\x07\x03\x12\x04\xa6\x01\
    \x14\x15\n\x0c\n\x04\x04\x0c\x02\x08\x12\x04\xa7\x01\x02\x16\n\r\n\x05\
    \x04\x0c\x02\x08\x05\x12\x04\xa7\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x08\
    \x01\x12\x04\xa7\x01\t\x11\n\r\n\x05\x04\x0c\x02\x08\x03\x12\x04\xa7\x01\
    \x14\x15\n\x0c\n\x04\x04\x0c\x02\t\x12\x04\xa8\x01\x02\x15\n\r\n\x05\x04\
    \x0c\x02\t\x05\x12\x04\xa8\x01\x02\x08\n\r\n\x05\x04\x0c\x02\t\x01\x12\
    \x04\xa8\x01\t\x0f\n\r\n\x05\x04\x0c\x02\t\x03\x12\x04\xa8\x01\x12\x14\n\
    \x0c\n\x02\x04\r\x12\x06\xab\x01\0\xb4\x01\x01\n\x0b\n\x03\x04\r\x01\x12\
    \x04\xab\x01\x08\x10\n\x0c\n\x04\x04\r\x02\0\x12\x04\xac\x01\x02\x12\n\r\
    \n\x05\x04\r\x02\0\x05\x12\x04\xac\x01\x02\x08\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xac\x01\t\r\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xac\x01\x10\x11\n\
    \x0c\n\x04\x04\r\x02\x01\x12\x04\xad\x01\x02\x12\n\r\n\x05\x04\r\x02\x01\
    \x05\x12\x04\xad\x01\x02\x08\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xad\x01\
    \t\r\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xad\x01\x10\x11\n\x0c\n\x04\x04\
    \r\x02\x02\x12\x04\xae\x01\x02\x13\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\
    \xae\x01\x02\x08\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xae\x01\t\x0e\n\r\n\
    \x05\x04\r\x02\x02\x03\x12\x04\xae\x01\x11\x12\n\x0c\n\x04\x04\r\x02\x03\
    \x12\x04\xaf\x01\x02\x1f\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xaf\x01\x02\
    \x08\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xaf\x01\t\x1a\n\r\n\x05\x04\r\
    \x02\x03\x03\x12\x04\xaf\x01\x1d\x1e\n\x0c\n\x04\x04\r\x02\x04\x12\x04\
    \xb0\x01\x02\x14\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xb0\x01\x02\x08\n\r\
    \n\x05\x04\r\x02\x04\x01\x12\x04\xb0\x01\t\x0f\n\r\n\x05\x04\r\x02\x04\
    \x03\x12\x04\xb0\x01\x12\x13\n\x0c\n\x04\x04\r\x02\x05\x12\x04\xb1\x01\
    \x02\x12\n\r\n\x05\x04\r\x02\x05\x05\x12\x04\xb1\x01\x02\x06\n\r\n\x05\
    \x04\r\x02\x05\x01\x12\x04\xb1\x01\x07\r\n\r\n\x05\x04\r\x02\x05\x03\x12\
    \x04\xb1\x01\x10\x11\n\x0c\n\x04\x04\r\x02\x06\x12\x04\xb2\x01\x02\x17\n\
    \r\n\x05\x04\r\x02\x06\x05\x12\x04\xb2\x01\x02\x08\n\r\n\x05\x04\r\x02\
    \x06\x01\x12\x04\xb2\x01\t\x12\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\xb2\
    \x01\x15\x16\n\x0c\n\x04\x04\r\x02\x07\x12\x04\xb3\x01\x02\x12\n\r\n\x05\
    \x04\r\x02\x07\x05\x12\x04\xb3\x01\x02\x08\n\r\n\x05\x04\r\x02\x07\x01\
    \x12\x04\xb3\x01\t\r\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\xb3\x01\x10\x11\
    \n\x0c\n\x02\x04\x0e\x12\x06\xb6\x01\0\xbb\x01\x01\n\x0b\n\x03\x04\x0e\
    \x01\x12\x04\xb6\x01\x08\x11\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xb7\x01\
    \x02\x12\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xb7\x01\x02\x08\n\r\n\x05\
    \x04\x0e\x02\0\x01\x12\x04\xb7\x01\t\r\n\r\n\x05\x04\x0e\x02\0\x03\x12\
    \x04\xb7\x01\x10\x11\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xb8\x01\x02\x12\
    \n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xb8\x01\x02\x08\n\r\n\x05\x04\x0e\
    \x02\x01\x01\x12\x04\xb8\x01\t\r\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \xb8\x01\x10\x11\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xba\x01\x02\x12\n\r\
    \n\x05\x04\x0e\x02\x02\x05\x12\x04\xba\x01\x02\x07\n\r\n\x05\x04\x0e\x02\
    \x02\x01\x12\x04\xba\x01\x08\r\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xba\
    \x01\x10\x11\n\x0c\n\x02\x05\x05\x12\x06\xbd\x01\0\xc7\x01\x01\n\x0b\n\
    \x03\x05\x05\x01\x12\x04\xbd\x01\x05\r\n\x0c\n\x04\x05\x05\x02\0\x12\x04\
    \xbe\x01\x02\x0c\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xbe\x01\x02\x07\n\r\
    \n\x05\x05\x05\x02\0\x02\x12\x04\xbe\x01\n\x0b\n\x0c\n\x04\x05\x05\x02\
    \x01\x12\x04\xbf\x01\x02\x0e\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\xbf\
    \x01\x02\x08\n\r\n\x05\x05\x05\x02\x01\x02\x12\x04\xbf\x01\x0b\r\n\x0c\n\
    \x04\x05\x05\x02\x02\x12\x04\xc0\x01\x02\x10\n\r\n\x05\x05\x05\x02\x02\
    \x01\x12\x04\xc0\x01\x02\n\n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\xc0\x01\
    \r\x0f\n\x0c\n\x04\x05\x05\x02\x03\x12\x04\xc1\x01\x02\x0c\n\r\n\x05\x05\
    \x05\x02\x03\x01\x12\x04\xc1\x01\x02\x06\n\r\n\x05\x05\x05\x02\x03\x02\
    \x12\x04\xc1\x01\t\x0b\n\x0c\n\x04\x05\x05\x02\x04\x12\x04\xc2\x01\x02\
    \x0e\n\r\n\x05\x05\x05\x02\x04\x01\x12\x04\xc2\x01\x02\x08\n\r\n\x05\x05\
    \x05\x02\x04\x02\x12\x04\xc2\x01\x0b\r\n\x0c\n\x04\x05\x05\x02\x05\x12\
    \x04\xc3\x01\x02\x10\n\r\n\x05\x05\x05\x02\x05\x01\x12\x04\xc3\x01\x02\n\
    \n\r\n\x05\x05\x05\x02\x05\x02\x12\x04\xc3\x01\r\x0f\n\x0c\n\x04\x05\x05\
    \x02\x06\x12\x04\xc4\x01\x02\x0c\n\r\n\x05\x05\x05\x02\x06\x01\x12\x04\
    \xc4\x01\x02\x06\n\r\n\x05\x05\x05\x02\x06\x02\x12\x04\xc4\x01\t\x0b\n\
    \x0c\n\x04\x05\x05\x02\x07\x12\x04\xc5\x01\x02\x0c\n\r\n\x05\x05\x05\x02\
    \x07\x01\x12\x04\xc5\x01\x02\x06\n\r\n\x05\x05\x05\x02\x07\x02\x12\x04\
    \xc5\x01\t\x0b\n\x0c\n\x04\x05\x05\x02\x08\x12\x04\xc6\x01\x02\x0f\n\r\n\
    \x05\x05\x05\x02\x08\x01\x12\x04\xc6\x01\x02\x08\n\r\n\x05\x05\x05\x02\
    \x08\x02\x12\x04\xc6\x01\x0b\x0e\n\x0c\n\x02\x04\x0f\x12\x06\xc9\x01\0\
    \xcd\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xc9\x01\x08\x10\n\x0c\n\x04\
    \x04\x0f\x02\0\x12\x04\xca\x01\x02\x17\n\r\n\x05\x04\x0f\x02\0\x05\x12\
    \x04\xca\x01\x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xca\x01\t\x12\n\
    \r\n\x05\x04\x0f\x02\0\x03\x12\x04\xca\x01\x15\x16\n\x0c\n\x04\x04\x0f\
    \x02\x01\x12\x04\xcb\x01\x02\x14\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\
    \xcb\x01\x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xcb\x01\t\x0f\n\r\
    \n\x05\x04\x0f\x02\x01\x03\x12\x04\xcb\x01\x12\x13\n\x0c\n\x04\x04\x0f\
    \x02\x02\x12\x04\xcc\x01\x02\x12\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\
    \xcc\x01\x02\x08\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xcc\x01\t\r\n\r\n\
    \x05\x04\x0f\x02\x02\x03\x12\x04\xcc\x01\x10\x11\n\x0c\n\x02\x04\x10\x12\
    \x06\xcf\x01\0\xdb\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xcf\x01\x08\
    \x0c\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xd0\x01\x02\x14\n\r\n\x05\x04\x10\
    \x02\0\x06\x12\x04\xd0\x01\x02\n\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xd0\
    \x01\x0b\x0f\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xd0\x01\x12\x13\n\x0c\n\
    \x04\x04\x10\x02\x01\x12\x04\xd1\x01\x02\x12\n\r\n\x05\x04\x10\x02\x01\
    \x05\x12\x04\xd1\x01\x02\x08\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xd1\
    \x01\t\r\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xd1\x01\x10\x11\n\x0c\n\
    \x04\x04\x10\x02\x02\x12\x04\xd2\x01\x02\x19\n\r\n\x05\x04\x10\x02\x02\
    \x05\x12\x04\xd2\x01\x02\x08\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xd2\
    \x01\t\x14\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xd2\x01\x17\x18\n\x0c\n\
    \x04\x04\x10\x02\x03\x12\x04\xd3\x01\x02\x1f\n\r\n\x05\x04\x10\x02\x03\
    \x05\x12\x04\xd3\x01\x02\x08\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xd3\
    \x01\t\x1a\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xd3\x01\x1d\x1e\n\x0c\n\
    \x04\x04\x10\x02\x04\x12\x04\xd4\x01\x02\x1e\n\r\n\x05\x04\x10\x02\x04\
    \x04\x12\x04\xd4\x01\x02\n\n\r\n\x05\x04\x10\x02\x04\x06\x12\x04\xd4\x01\
    \x0b\x13\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\xd4\x01\x14\x19\n\r\n\x05\
    \x04\x10\x02\x04\x03\x12\x04\xd4\x01\x1c\x1d\n\x0c\n\x04\x04\x10\x02\x05\
    \x12\x04\xd5\x01\x02\x14\n\r\n\x05\x04\x10\x02\x05\x05\x12\x04\xd5\x01\
    \x02\x08\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\xd5\x01\t\x0f\n\r\n\x05\
    \x04\x10\x02\x05\x03\x12\x04\xd5\x01\x12\x13\n\x0c\n\x04\x04\x10\x02\x06\
    \x12\x04\xd6\x01\x02\x13\n\r\n\x05\x04\x10\x02\x06\x05\x12\x04\xd6\x01\
    \x02\x08\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xd6\x01\t\x0e\n\r\n\x05\
    \x04\x10\x02\x06\x03\x12\x04\xd6\x01\x11\x12\n\x0c\n\x04\x04\x10\x02\x07\
    \x12\x04\xd8\x01\x02&\n\r\n\x05\x04\x10\x02\x07\x04\x12\x04\xd8\x01\x02\
    \n\n\r\n\x05\x04\x10\x02\x07\x06\x12\x04\xd8\x01\x0b\x13\n\r\n\x05\x04\
    \x10\x02\x07\x01\x12\x04\xd8\x01\x14!\n\r\n\x05\x04\x10\x02\x07\x03\x12\
    \x04\xd8\x01$%\n\x0c\n\x04\x04\x10\x02\x08\x12\x04\xda\x01\x02\x1b\n\r\n\
    \x05\x04\x10\x02\x08\x04\x12\x04\xda\x01\x02\n\n\r\n\x05\x04\x10\x02\x08\
    \x05\x12\x04\xda\x01\x0b\x10\n\r\n\x05\x04\x10\x02\x08\x01\x12\x04\xda\
    \x01\x11\x16\n\r\n\x05\x04\x10\x02\x08\x03\x12\x04\xda\x01\x19\x1a\n\x0c\
    \n\x02\x05\x06\x12\x06\xdd\x01\0\xe3\x01\x01\n\x0b\n\x03\x05\x06\x01\x12\
    \x04\xdd\x01\x05\r\n\x0c\n\x04\x05\x06\x02\0\x12\x04\xde\x01\x02\x0b\n\r\
    \n\x05\x05\x06\x02\0\x01\x12\x04\xde\x01\x02\x06\n\r\n\x05\x05\x06\x02\0\
    \x02\x12\x04\xde\x01\t\n\n\x0c\n\x04\x05\x06\x02\x01\x12\x04\xdf\x01\x02\
    \x0f\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\xdf\x01\x02\n\n\r\n\x05\x05\
    \x06\x02\x01\x02\x12\x04\xdf\x01\r\x0e\n\x0c\n\x04\x05\x06\x02\x02\x12\
    \x04\xe0\x01\x02\x10\n\r\n\x05\x05\x06\x02\x02\x01\x12\x04\xe0\x01\x02\
    \x0b\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\xe0\x01\x0e\x0f\n\x0c\n\x04\
    \x05\x06\x02\x03\x12\x04\xe1\x01\x02\x0b\n\r\n\x05\x05\x06\x02\x03\x01\
    \x12\x04\xe1\x01\x02\x06\n\r\n\x05\x05\x06\x02\x03\x02\x12\x04\xe1\x01\t\
    \n\n\x0c\n\x04\x05\x06\x02\x04\x12\x04\xe2\x01\x02\x0c\n\r\n\x05\x05\x06\
    \x02\x04\x01\x12\x04\xe2\x01\x02\x07\n\r\n\x05\x05\x06\x02\x04\x02\x12\
    \x04\xe2\x01\n\x0b\n\x0c\n\x02\x04\x11\x12\x06\xe5\x01\0\xeb\x01\x01\n\
    \x0b\n\x03\x04\x11\x01\x12\x04\xe5\x01\x08\x0c\n\x0c\n\x04\x04\x11\x02\0\
    \x12\x04\xe6\x01\x02\x12\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xe6\x01\x02\
    \x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xe6\x01\t\r\n\r\n\x05\x04\x11\
    \x02\0\x03\x12\x04\xe6\x01\x10\x11\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\
    \xe7\x01\x02\x13\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xe7\x01\x02\x08\n\
    \r\n\x05\x04\x11\x02\x01\x01\x12\x04\xe7\x01\t\x0e\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\xe7\x01\x11\x12\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xe8\
    \x01\x02\x14\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xe8\x01\x02\n\n\r\n\
    \x05\x04\x11\x02\x02\x01\x12\x04\xe8\x01\x0b\x0f\n\r\n\x05\x04\x11\x02\
    \x02\x03\x12\x04\xe8\x01\x12\x13\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\xe9\
    \x01\x02\x1e\n\r\n\x05\x04\x11\x02\x03\x05\x12\x04\xe9\x01\x02\x08\n\r\n\
    \x05\x04\x11\x02\x03\x01\x12\x04\xe9\x01\t\x19\n\r\n\x05\x04\x11\x02\x03\
    \x03\x12\x04\xe9\x01\x1c\x1d\n\x0c\n\x04\x04\x11\x02\x04\x12\x04\xea\x01\
    \x02\x12\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\xea\x01\x02\x08\n\r\n\x05\
    \x04\x11\x02\x04\x01\x12\x04\xea\x01\t\r\n\r\n\x05\x04\x11\x02\x04\x03\
    \x12\x04\xea\x01\x10\x11b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
